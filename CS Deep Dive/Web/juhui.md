1. HTTP 상태코드 3xx, 4xx, 5xx는 각각 무엇을 의미하나요? 4xx 중 401과 403의 차이는?
   3xx
   Redirection을 의미하며 요청은 정상적이지만 클라이언트가 다른 위치로 이동해야 함을 의미하는 코드입니다.
   4xx
   Client Error를 의미하며 클라이언트 측의 잘못된 요청을 의미합니다.
   5xx
   Server Error를 의미하며 서버 측에서 요청을 정상적으로 처리하지 못했을 때 발생하는 에러입니다.
   4xx 중 401과 403의 차이는 401은 Unauthorized로 인증이 필요한 리소스에 대해 인증 정보가 없거나 유효하지 않을 때 발생하는 코드입니다. 403은 Forbidden으로 인증은 되었지만 해당 자원에 접근 권한이 없는 경우 발생합니다.

2. Keep-Alive가 무엇인가요? 왜 필요한가요?
   Heepp-Alive는 HTTP 연결을 재사용할 수 있도록 유지하는 기술입니다. 기본적으로 HTTP/1.0에서는 클라이언트가 서버에 요청을 보내고 응답을 받으면, TCP 연결이 바로 종료됩니다. 하지만 웹 페이지는 HTML 외에도 이미지, CSS, JS 등 여러 리소스를 동시에 요청해야하므로 매번 새로운 TCP 연결을 생성하고 끊는 과정은 지연과 리소스 낭비를 초래합니다. 이를 해결하기 위해 HTTP/1.1부터는 기본적으로 Connection:keep-alive가 적용되어 하나의 TCP 연결을 여러 오청 응답에 재사용할 수 있게 되었습니다. 이로 인해 TCP 연결 수립과 종료 과정에 드는 시간과 오버헤드가 줄어들고, 전체 응답 속도와 성능이 향상됩니다.
   Keep-Alive는 특히 리소스를 많이 요청하는 웹 페이지나 짧은 시간 안에 여러 요청을 보내는 REST API 등에서 큰 효과를 발휘하며, 서버와 클라이언트 모두에 부하를 줄여주는 장점이 있습니다. 다만, 너무 많은 연결을 오래 유지하면 서버 자원을 고갈시킬 수 있기 때문에 Keep-Alive 타임아웃이나 최대 요청 수 제한 등을 설정해 적절히 관리해야 합니다.

3. JWT(Json Web Token)의 구조와 장단점을 설명해주세요.
   JWT는 사용자 인증 및 정보 전달을 위해 사용되는 자기 포함형 토큰입니다. 클라이언트와 서버 간에 인증 정보를 주고받을 때 주로 사용되며, 토큰 자체에 필요한 정보를 담고 있기 떄문에 별도의 세션 저장소 없이도 무상태(stateless) 인증이 가능합니다.
   jwt는 크게 header, Payload, Signature 3가지로 나눌 수 있습니다. Header는 알고리즘(alg)과 타입(typ) 정보를 담고 있습니다. Payload는 사용자 식별 정보와 토큰의 유효시간등의 클레임(claims)이 포함됩니다. Signature는 Header와 Payload를 합친 문자열에 비밀 키를 이용해 서명한 값으로 토큰의 위변조 여부를 검증하는데 사용됩니다.
   jwt 구조의 장점은 서버가 상태를 저장하지 않아도 되고 토큰 자체에 필요한 정보를 포함합니다. 그리고 다양한 플랫폼(모바일, API, 프론트앤드 등) 간 통신에 유리합니다.
   단점은 토큰 탈취 시 정보 노출 및 오용의 위험이 있는 것과 서버에서 토큰 강제 무효화가 어려운 점 그리고 Payload가 인코딩만 되어 있어서 민감 정보 포함을 주의해야하는 점입니다.

   # 📅 2025/05/30

4. JWT를 사용할 때 발생할 수 있는 보안 문제와 이를 해결하는 방법은 무엇인가요?

   1. 토큰 탈취 시 재사용 공격이 가능합니다.
      만약 공격자가 토큰을 탈취하면, 별도의 인증 없이 서버 자원에 접근할 수 있습니다.
      대응 방법으로는, HTTPS를 반드시 사용하여 네트워크 상에서 토큰이 노출되지 않도록 하고, 토큰의 만료 시간을 짧게 설정하는 것이 중요합니다.

   2. 서명 알고리즘을 악용한 공격입니다.
      예를 들어, none 알고리즘을 허용하거나 알고리즘이 변경될 수 있는 경우, 공격자가 서명 없이 위조된 토큰을 만들 수 있습니다.
      대응 방법으로는, 서버에서 허용할 알고리즘을 명확히 지정하고, none 알고리즘을 절대 허용하지 않아야 합니다.

   3. 토큰 저장 방식에 따른 취약점입니다.
      토큰을 브라우저의 localStorage에 저장하면, XSS 공격에 노출될 위험이 있습니다.
      대응 방법으로는, HttpOnly, Secure 옵션이 적용된 쿠키를 사용하거나, XSS 방어를 철저히 구현해야 합니다.

5. OAuth2.0 인증 플로우를 설명해주세요. OAuth2를 사용할 때 주의해야 할 점은?

   인증 플로우

   1. 사용자가 클라이언트(앱)에서 인증 요청을 시작합니다.
   2. 클라이언트는 인증 서버(Authorization Server)로 리다이렉트합니다.
   3. 사용자는 인증 서버에서 로그인 및 권한 승인을 진행합니다.
   4. 인증 서버는 클라이언트에게 Authorization Code를 발급합니다.
   5. 클라이언트는 이 코드를 인증 서버에 보내고, Access Token을 받습니다.
   6. 이후 클라이언트는 이 Access Token을 활용하여 자원 서버(Resource Server)에 접근합니다.

   OAuth2 사용 시 주의할 점은 다음과 같습니다.

   - Access Token과 Refresh Token은 반드시 안전하게 보관하고, 네트워크 상에서는 HTTPS만 사용해야 합니다.
   - Redirect URI를 화이트리스트로 관리하여, 악성 사이트로 토큰이 노출되는 것을 방지해야 합니다.
   - Scope(권한 범위)를 최소화하여, 불필요한 권한이 부여되지 않도록 주의해야 합니다.
   - 토큰 탈취/재사용 공격을 막기 위해, 토큰의 만료 주기와 갱신 정책도 신경 써야 합니다.

6. Session 기반 인증과 Token 기반 인증의 차이는 무엇인가요?
   **Session 기반 인증**은 서버가 사용자의 로그인 상태를 세션에 저장하고, 클라이언트는 세션 ID를 쿠키로 받아 서버에 전달하는 구조입니다.
   서버가 상태 정보를 관리하기 때문에, 확장성에 제한이 있을 수 있지만, 세션 폐기 등 관리가 용이합니다.

   **Token 기반 인증(JWT 등)**은 서버가 별도의 상태를 저장하지 않고, 로그인 시 토큰을 클라이언트에 발급합니다.
   클라이언트는 이후 요청마다 토큰을 서버에 전달하며, 서버는 토큰의 유효성만 검증합니다.
   이 방식은 서버가 무상태(Stateless)이므로 확장성과 분산 환경에 적합합니다.

   정리하자면,
   Session 기반은 서버 상태 유지가 필요하지만, 관리가 편리하고,
   Token 기반은 확장성이 뛰어나지만, 토큰 관리와 보안에 더 많은 신경이 필요합니다.
