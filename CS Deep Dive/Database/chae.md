# 📅 2025/05/02
# 키(Key)에 대해 설명해주세요.
- 키는 데이터베이스에서 조건에 만족하는 관계의 행을 찾거나 순서대로 정렬할 때 다른 행과 구별할 수 있는 유리한 기준이 되는 속성의 집합이다.

## 키(Key)의 종류
- 슈퍼 키 : 유일성을 만족하는 키. relation 내에 있는 속성들의 집합으로 구성된 키. (유일성: 하나의 키로 특정 행을 바로 찾아낼 수 있는 고유한 데이터 속성)
- 후보 키 : 유일성과 최소성을 만족하는 키. (최소성: 키를 구성하는 속성들 중 가장 최소로 필요한 속성들로만 키를 구성하는 성질)
- 기본 키 : 후보키들 중에서 하나를 선택한 키로 유일성과 최소성을 만족하는 속성. NULL 불가능, 중복된 값 X, 오직 1개만 저장 가능
- 대체 키 : 후보키가 두 개 이상일 경우 그 중에서 하나를 기본키로 지정하고 남은 후보키들을 대체키. 
- 복합 키 : 하나의 속성으로는 기본키가 될 수 없는 둘 이상의 컬럼을 묶어서 식별자로 정의.
- 외래 키 : 테이블이 다른 테이블의 데이터를 참조하여 테이블간의 관곌르 연결. 

---

# JOIN에 대해 설명해주세요.
- JOIN은 데이터베이스에서 두 개 이상의 테이블을 연결하여 하나의 결과 테이블로 만드는 것을 의미. 
- 데이터베이스에서 테이블을 분리하여 '데이터 중복을 최소화'하고 '데이터의 일관성'을 유지하기 위함

## JOIN 의 종류
- INNER JOIN : 교집합의 개념 
- OUTER JOIN(LEFT, RIGHT, FULL) : 특정 테이블 기준으로, FULL의 경우는 합집합(모든 데이터 선택) 
- CROSS JOIN : 두 테이블의 행의 개수의 곱
- SELF JOIN : 자기 자신과 조인

---  

# SQL Injection이란?
- 웹 사이트의 보안상 허점을 이용해 특정 SQL 쿼리 문을 전송하여 공격자가 원하는 DB의 중요한 정보를 가져오는 해킹 기법

## SQL Injection 대응
- 1. 입력 값에 대한 검증 필요
- 2. Prepared Statement 구문 사용 : 변수를 문자열로 바꾸라는 것으로 안전하다. 사용자의 입력 값이 데이터베이스의 파라미터로 들어가기 전에 DBMS가 미리 컴파일하여 실행하지 않고 대기한다. 그 후 사용자의 입력 값을 문자열로 인식하게 하여 공격 쿼리가 들어간다고 하더라도, 사용자의 입력은 이미 의미 없는 단순 문자열 이기 때문에 전체 쿼리문도 공격자의 의도대로 작동하지 않는다.
- 3. Error Message 노출 금지 : 에러 발생한 쿼리문 내용을 반환하면 쿼리문이 노출되기 때문에
- 4. 웹 방화벽 사용 : 소프트웨어 형(서버 내에 직접 설치), 하드웨어 형(네트,워크 상에서 서버 앞 단에 직접 하드웨어 장비로 구성), 프록시 형(DNS 서버 주소를 웹 방화벽으로 바꾸고 서버로 가는 트래픽이 웹 방화벽을 먼저 거치도록 하는 방법.)


# 📅 2025/05/21
# RDBMS vs NoSQL에 대해 설명해주세요
# RDBMS(Relational Database Management System)
- 관계형 데이터베이스 관리 시스템
- 관계형 데이터 모델을 기초로 두고 **모든 데이터를 2차원의 열과 행(테이블)의 형태로 표현**
- 외래 키(foreign key)를 사용하여 테이블 간 join이 가능
- ACID(Atomicity, Consistency, Isolation, Durability) 원칙을 기본으로 구성

## RDBMS 장점
- 정해진 스키마에 따라 데이터를 저장해야 해서 명확한 데이터 구조 보장 (데이터 정합성)
- 각 데이터를 중복 없이 한 번만 저장 가능 (데이터 무결성)

## RDBMS 단점
- 테이블 간 관계를 맺고 있어 시스템이 커질 경우 JOIN문이 많은 복잡한 쿼리 발생 가능
- 성능 향상을 위해 Scale-Up만 지원 -> Scale-Out이 불가능하기 때문에 처리 비용이 기하급수적으로 커질 수 있음
- 스키마로 인해 데이터가 유연하지 못함 -> 나중에 스키마가 변경될 경우 번거롭고 어려움

![alt text](./img/image-1.png)
### Scale-up
- 기존의 서버를 보다 높은 사양으로 업그레이드하는 것
- 하나의 서버의 능력을 증강하기 때문에 수직 스케일링(vertical scaling)이라고도 함


![alt text](./img/image-2.png)
### Scale-out
- 장비를 추가해 확장하는 방식
- 서버를 추가로 확장하기 때문에 수평 스케일링(horizontal scaling)이라고도 함
- 비슷한 사양의 서버를 추가로 연결해 처리할 수 있는 데이터의 용량 증가뿐만 아니라 기존 서버의 부하를 분담해 성능도 향상

# NoSQL(Not Only SQL)
- RDBMS의 성능과 한계를 극복하기 위해 등장
- ACID 특성을 제공하지 않지만 뛰어난 확장성이나 성능 등의 특성을 가짐
- 테이블 간의 관계 정의가 X, JOIN 필요 X

## NoSQL 모델 종류
1. Key-Value DB
- Key-Value 방식으로 데이터를 저장 
- Key값은 모든 데이터 타입을 수용할 수 있고, 중복되지 않는 유니크한 값
- 메모리 기반으로 빠르게 데이터를 읽어올 수 있음 
ex) Redis, AWS Dynamo DB

2. Document DB
- 비정형 대량 데이터를 저장하기 위한 방식
- Key-Value에서 확장된 방식으로, key-Document 형태로 저장
- Document는 계층적인 데이터 타입(JSON,XML)으로 저장됨
- JSON 타입을 사용하므로 HTTP 기반의 웹 서버의 경우 데이터를 편리하게 주고받을 수 있음
ex) MongoDB, Couch DB

3. Wide Column DB
- Row가 아닌 Column 위주로 데이터를 저장하는 방식
- Key, Value와 유사한 형태의 Column-family Model
- 데이터가 내부에서 Key를 기준으로 오름차순 저장
- 이전의 모델들이 key-value값을 이용해 필드를 가졌다면, 이 모델은 키에서 필드를 결정
ex) HBase, Hypertable

4. Graph DB
- 객체와 관계를 그래프 형식의 데이터로 저장하기 위한 방식
- 데이터를 Node와 Edge, Property와 함께 그래프 구조를 사용하여 데이터를 저장
- SNS, Networ Diagrams 등과 SNS에서 함께 아는 친구 찾기, 추천 등 연관된 데이터를 추천해주는 엔진이나 패턴 기능에 사용
ex) Neo4j

## NoSQL 장점
- 스키마 없어 유연하고 자유로운 데이터 구조 (언제든 저장된 데이터 조정과 새로운 필드 추가가 가능)
- 성능 향상을 위해 Scale-up/Scale-out이 모두 가능 (데이터 분산이 용이, RDBMS에 비해 대용량의 데이터 저장 가능)

## NoSQL 단점
- 스키마가 존재하지 않아 데이터의 일관성이 존재하지 않고 데이터 구조를 결정하기 어려울 수 있음
- 데이터의 중복 발생 가능 


# 정규화(Nomalization)란?
- SQL 정규화란 데이터베이스 설계 과정에서 **중복 데이터를 최소화**하고 **데이터 일관성을 유지**하기 위한 중요한 원칙 중 하나이다. 정규화는 데이터베이스 테이블을 여러 테이블로 분할하고, 이러한 테이블 간의 관계를 정의함으로써 데이터를 더 효율적으로 저장하고 관리하는 방법

## 정규화의 목적
- 중복 데이터 제거 
- 데이터 무결성 유지

## 정규화의 절차
1. 제 1정규형: 1NF(First Normal Form)
- 원자값(Atomic Values) : 각 열은 원자적인 값(더 이상 분해할 수 없는 값, 하나의 값)을 가져야한다.
- 고유한 식별자(Unique Identifier) : 각 행은 고유한 식별자(primary key)를 가져야 한다.
- 중복 데이터 제거(No Duplicate Rows) : 동일한 데이터가 중복으로 나타나지 않아야 한다.

2. 제 2정규형 : 2NF(Second Normal Form)
- 1NF 만족: 1NF를 만족해야 한다.
- 부분 종속성 제거: 테이블의 모든 컬럼이 완전 함수적 종속을 만족해야 한다. 테이블에서 기본키가 복합키(키1,키2)로 묶여있을 때, 두 키 중 하나의 키만으로 다른 컬럼을 결정 지을 수 있으면 안된다.

3. 제 3정규형 : 3NF(Third Normal Form)
- 데이터베이스 정규화의 세 번째 단계로, 2NF를 만족하면서 이행 종속성을 제거하는 것이 목적이다.
- 2NF 만족
- 기본키 의존 : 기본키가 아닌 속성들은 기본키에 의존해야 한다.

4. BCNF (Boyce-Codd Normal Form)
- 주로 다중 후보 키와 관련된 테이블에서 발생한다.
- 3NF 만족 
- 후보 키에 대한 함수 종속성 : 모든 결정자가 후보키가 되도록 테이블을 분해하는 것. 즉, 후보키 집합에 없는 칼럼이 결정자가 되어서는 안된다는 뜻.

5.  제 4정규형 : 4NF (Fourth Normal Form)
- 보통 정규화는 BCNF 까지만 하는 경우가 많다. 그 이상 정규화를 하면 정규화의 단점이 나타날 수 있다.
- 다치 종속성 (Multivalued Dependency) : 다치 종속성은 테이블의 열들 간에 다중 값 종속성을 나타낸다. 즉, 하나의 키(주요 키 또는 후보 키)에 대한 여러 개의 값 집합이 있을 때 다치 종속성이 발생한다.
- 후보 키의 독립성 : 테이블이 여러 개의 후보 키를 가질 때, 한 후보 키의 값을 변경할 때 다른 후보 키에 영향을 주어서는 안 된다.

6. 제 5정규형 : 5NF (Fifth Normal Form)
- 조인 종속성을 처리하기 위해 추가적인 정규화 단계로, 복잡성과 성능 문제로 현실적으로 잘 사용되지 않는다.
- 4NF 만족
- 조인 종속성 (Join Dependency) : 조인 종속성이 없어야 하고, 조인 연산을 했을 때 손실이 없어야 한다.

## 정규화의 단점
- 테이블의 분해로 인해 데이터베이스 내의 JOIN 연산이 많아져, 쿼리 성능이 저하될 수 있다. 특히 대규모 데이터베이스에서는 조인 비용이 높아질 수 있다.
- 따라서, 처리 성능이 중요한 데이터에 대해 '반정규화(De-normalization)'하기도 한다.

## 반정규화란?
- 데이터베이스의 성능 향상을 위하여, 데이터 중복을 허용하고 조인을 줄이는 데이터베이스 성능 향상 방법이다.
- 반정규화는 조회(select) 속도를 향상시키지만, 데이터 모델의 유연성은 낮아진다.


# 인덱스(INDEX)란?
- 인덱스란, 데이터베이스에서 데이터를 더 빠르게 검색할 수 있게 해주는 자료구조이다.

## 인덱스의 종류
### 클러스터형 인덱스(Clustered Index)
- 클러스터형 인덱스(Clustered Index)란 데이터 행의 원래 순서대로 저장되어 있는 인덱스를 의미
- 데이터의 저장 순서 그대로 되어있기 때문에 **각 테이블은 단 하나의 클러스터형 인덱스**를 가질 수 있다. 또한, 클러스터형 인덱스는 행 데이터를 지정한 열에 맞춰 자동으로 정렬한다.
- 클러스터형 인덱스는 '영어사전'이다. 영어사전은 책 내용자체가 알파벳 순서로 되어 있기 때문에 그 자체가 인덱스가 된다.

### 보조형 인덱스(Secondary Index)
- 보조형 인덱스(Seconday Index)란 실제 데이터의 위치와는 별개로 저장되는 인덱스를 의미
- 보조형 인덱스는 인덱스의 기준이 되는 컬럼을 기준으로 실제 데이터와는 다른 별도의 순서를 가진다. 그렇기 때문에 각 테이블은 여러 개의 보조형 인덱스를 가질 수 있다.
- 보조형 인덱스는 '일반적인 목차가 있는 책'이다. 책 내용은 특정 키워드 순서로 진행되는 것은 아니지만 목차를 통해 그 키워드를 찾아 접근할 수 있듯, 보조형 인덱스도 데이터의 저장 순서와는 상관없이 존재한다.

## 인덱스의 장점
- 검색(Select)하는 속도가 매우 빨라진다.(항상 그런 것은 아님)
- 쿼리의 부하가 줄어들어 시스템의 성능이 향상됨

## 인덱스의 단점
- 데이터베이스 크기의 10% 정도의 추가적인 공간이 필요해진다.
- 데이터의 변경(Insert, Update, Delete)작업이 자주 일어나는 경우 오히려 성능이 나빠질 수도 있다.

## 인덱스를 사용하면 좋은 경우
- 해당 컬럼이 Where조건에 자주 사용되는 경우
- 해당 컬럼이 Join의 조건이 되는 경우
- 해당 테이블의 데이터의 변경(Insert, Update, Delete) 작업이 자주 일어나지 않는 경우


# 📅 2025/06/05
# 트랜잭션(Transaction)란?
- 트랜잭션(Transaction)은 **데이터베이스 시스템에서 하나의 논리적인 작업 단위**를 의미.
- 즉, 여러 개의 연산들이 모여 하나의 완전한 작업을 구성하고, 이 작은 모두 성공하거나 실패해야 한다는 원자성을 보장한다. 

## 트랜잭션의 ACID 속성
- 데이터베이스 트랜잭션은 그 신뢰성을 보장하기 위해 4가지 속성을 갖춰야 한다.
1. 원자성(Atomicity)
- 트랜잭션 내의 모든 연산은 마치 하나의 행위처럼 모두 성공하거나 실패해야 한다. 부분적으로만 반영되는 것은 허용되지 않는다.
2. 일관성(Consistency)
- 트랜잭션이 실행되기 전후에 데이터베이스의 상태는 항상 일관성을 유지해야 한다. 
3. 고립성(Isolation)
- 동시에 여러 트랜잭션이 실행되더라도, 각 트랜잭션은 마치 독립적으로 실행되는 것처럼 다른 트랜잭션의 영향을 받지 않아야 한다
4. 지속성(Durability)
- 트랜잭션이 성공적으로 완료되면, 그 결과는 영구적으로 데이터베이스에 반영되야 한다. 시스템 장애가 발생하더라도 데이터는 안전하게 보존되어야 한다.

# 트랜잭션 격리 수준(Transaction Isolation Level) 란?
- 트랜잭션의 격리 수준(Isolation Level)이란 **여러 트랜잭션이 동시에 처리될 때, 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 여부를 결정하는 것**이다. 

## SQL 표준 4가지 격리 수준
-  (아래로 갈수록 격리 수준이 높아짐)

1. READ UNCOMMITTED (커밋되지 않은 읽기)
- 가장 낮은 격리 수준.
- **더티 리드(Dirty Read)** 발생 가능.
- 한 트랜잭션이 다른 트랜잭션이 아직 커밋하지 않은 데이터를 읽을 수 있습니다. 변경된 데이터가 롤백될 수도 있는데도 읽을 수 있다는 의미입니다. 동시성은 가장 높지만 데이터 일관성이 심각하게 훼손될 수 있습니다.

2. READ COMMITTED (커밋된 읽기)
- 많은 데이터베이스 시스템의 기본 격리 수준 (예: PostgreSQL, Oracle).
- 더티 리드 방지. 하지만 **반복 불가능한 읽기(Non-Repeatable Read)**와 유령 읽기(Phantom Read) 발생 가능.
- 한 트랜잭션은 다른 트랜잭션에 의해 커밋된 데이터만 읽을 수 있습니다. 즉, 롤백될 수 있는 '더티' 데이터는 읽지 않습니다. 하지만 동일 트랜잭션 내에서 같은 쿼리를 다시 실행하면 다른 트랜잭션에 의해 변경/추가/삭제된 커밋된 데이터를 볼 수 있어 결과가 달라질 수 있습니다.

3. REPEATABLE READ (반복 가능한 읽기)
- MySQL InnoDB 스토리지 엔진의 기본 격리 수준.
- **더티 리드와 반복 불가능한 읽기 방지.** 하지만 **유령 읽기(Phantom Read)** 발생 가능.
- 트랜잭션이 시작된 시점부터 끝날 때까지 동일한 데이터를 여러 번 읽어도 항상 동일한 결과를 보장합니다. 이는 트랜잭션이 읽은 모든 행에 대해 잠금(Shared Lock)을 걸거나, MVCC(Multi-Version Concurrency Control)를 통해 트랜잭션 시작 시점의 스냅샷을 이용하는 방식으로 구현됩니다. 하지만 새로운 레코드 삽입(Phantom Read)은 막지 못할 수 있습니다. (MySQL InnoDB는 넥스트-키 락(Next-Key Lock)을 사용하여 Phantom Read도 방지합니다.)

4. SERIALIZABLE (직렬화 가능)
- 가장 높은 격리 수준.
- 모든 이상 현상(더티 리드, 반복 불가능한 읽기, 유령 읽기) 방지.
- 모든 트랜잭션이 순차적으로(직렬적으로) 실행되는 것과 동일한 결과를 보장합니다. 즉, 동시성을 희생하여 완벽한 데이터 일관성을 얻습니다. 이를 위해 광범위한 잠금(Locking)이 사용되므로, 동시성이 매우 떨어져 성능 저하가 가장 심합니다. 실제 운영 환경에서는 극히 드물게 사용됩니다


# 저장 프로시저(Stroed Procedure)란?
- 저장 프로시저(Stored Procedure)는 데이터베이스 관리 시스템(DBMS)에 **미리 컴파일되어 저장되는 일련의 SQL 명령문 집합**입니다. 
- 쉽게 말해, 특정 작업을 수행하는 SQL 코드 묶음을 만들어 이름을 붙여 데이터베이스 내부에 저장해 두고, 필요할 때마다 그 이름을 호출하여 실행할 수 있도록 하는 기능입니다.

## 저장 프로시저의 주요 특징 및 목적
1. 성능 향상 (Pre-compiled)
- 저장 프로시저는 한 번 정의되어 저장될 때 미리 컴파일됩니다. 이는 프로시저가 호출될 때마다 SQL 구문을 분석하고 실행 계획을 세우는 과정을 생략할 수 있게 하여, 실행 속도를 향상시킵니다.
- 네트워크 트래픽 감소: 여러 SQL 문을 한 번의 호출로 실행할 수 있어 클라이언트와 서버 간의 네트워크 통신 횟수를 줄여줍니다.

2. 재사용성 (Reusability)
- 자주 사용되는 복잡한 SQL 로직을 하나의 프로시저로 캡슐화하여 여러 애플리케이션이나 다른 프로시저에서 반복적으로 호출하여 사용할 수 있습니다.
- 개발 효율성 증대: 동일한 로직을 매번 작성할 필요 없이, 저장된 프로시저를 호출하기만 하면 됩니다.

3. 유지보수 용이성 (Maintainability)
- 비즈니스 로직이 변경될 때, 저장 프로시저 내부의 코드만 수정하면 되므로, 이를 사용하는 모든 애플리케이션의 코드를 수정할 필요가 없습니다.
- 중앙 집중식 관리: 데이터베이스 내에서 로직이 관리되므로 버전 관리 및 일관성 유지에 유리합니다.

4. 보안 강화 (Security)
- 사용자에게 테이블에 대한 직접적인 접근 권한을 부여하지 않고, 저장 프로시저에 대한 실행 권한만 부여할 수 있습니다. 이를 통해 사용자가 데이터에 접근하거나 조작하는 방식을 제한하고 통제할 수 있습니다.
- 데이터 은닉: 내부 테이블 구조나 복잡한 로직을 외부에 노출하지 않고 안전하게 데이터를 처리할 수 있습니다.

5. 트랜잭션 관리 용이 (Transaction Management)
- 저장 프로시저 내에서 여러 SQL 문을 하나의 트랜잭션으로 묶어 BEGIN TRANSACTION, COMMIT, ROLLBACK 등의 명령어를 사용하여 데이터의 일관성을 쉽게 관리할 수 있습니다.