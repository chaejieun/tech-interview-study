# JAVA
### 1. JVM의 구조와 Java의 실행방식을 설명해주세요.
- JVM: Java 바이트코드를 실행하는 가상 머신
- JVM 구조 
  - Class Loader (클래스 로더): .class 파일(바이트코드)을 로딩하여 JVM 메모리에 올림
  - Execution Engine (실행 엔진): 로딩된 바이트코드를 실제 기계어로 변환하여 실행
    - 인터프리터
    - JIT 컴파일러
  - Runtime Data Area (런타임 메모리): JVM이 실행 중 사용하는 모든 메모리 공간
    - Method Area: 클래스 정보              
    - Heap: 객체
    - Stack: 호출 시 데이터
    - PC Register
    - Native Method Stack
  - Native Interface: Java에서 C/C++로 작성된 네이티브 메서드를 호출할 수 있게 해줌
  - Native Libraries: OS 레벨에서 사용하는 라이브러리(C/C++ 등)를 로드

- 실행 방식 
  - 작성: Java 소스코드 (.java)
  - 컴파일: javac 명령으로 바이트코드 (.class)로 컴파일됨 
    → 이때 기계어가 아닌 JVM이 이해할 수 있는 중간 형태로 변환됨 
  - 실행:
    - Execution Engine이 바이트코드를 인터프리팅 또는 JIT(Just-In-Time) 컴파일하여 실행
    - 이때 필요한 메모리는 Runtime Data Area에 적재됨
    
### 2. GC(Garbage Collection)가 무엇인지, 필요한 이유는 무엇인지, 동작방식에 대해 설명해주세요.
- Heap 메모리에서 더 이상 사용되지 않는 객체를 런타임 환경에서 자동으로 제거해주는 Java의 메모리 관리 기능

- 왜 필요한가? 
  - Java는 개발자가 메모리 해제를 직접 하지 않기 때문에, 불필요한 객체를 자동으로 정리하지 않으면 메모리 누수가 발생할 수 있음
  - 개발자는 비즈니스 로직에 집중, 메모리 관리는 JVM이 담당 

- 동작 방식 
  - Mark(표시) 단계
    - 루트(Root) 집합에서 시작하여 모든 도달 가능한(Reachable) 객체를 추적해 마크를 표시
    - 루트는 스택 변수, 정적 필드, 스레드, JNI 참조 등을 포함 
  - weep(스윕) 단계 
    - 힙 메모리를 순회하면서 마크되지 않은 객체를 '가비지'로 간주해 해제
  - Compact(압축) 단계 (선택적):
    - 일부 GC 알고리즘에서는 살아남은 객체들을 메모리의 한쪽으로 모아 메모리 단편화를 줄임

- GC 알고리즘 종류 (JVM에 따라 선택 가능)
  - Serial GC: 단일 스레드, 작은 애플리케이션에 적합 
  - Parallel GC: 멀티스레드로 처리, Throughput 중심 
  - CMS GC (Deprecated): 응답시간 단축 중심 
  - G1 GC: 대용량 Heap을 위한 점진적 GC 
  - ZGC, Shenandoah: 지연시간 최소화 (대규모 시스템에 적합)

### 3. 객체지향에 대해서 설명해주세요.
- 현실 세계의 객체를 추상화하여 소프트웨어로 모델링하는 개발 방법
- 원칙
  - 추상화: 객체의 핵심 속성과 동작만 모델링 (불필요한 것은 감춤)
  - 캡슐화: 데이터와 메서드를 하나로 묶고, 외부에 직접 접근을 제한 (private, getter/setter)
  - 상속: 부모 클래스의 속성과 기능을 자식 클래스가 물려받음 (재사용성 증가)
  - 다형성: 하나의 인터페이스나 메서드가 여러 동작을 수행할 수 있음 (오버라이딩, 오버로딩)
- 객체지향의 장점
  - 코드 재사용성 (상속)
  - 유지보수성 (모듈화)
  - 확장성 (다형성)
  - 직관적인 구조 (현실 세계와 유사)