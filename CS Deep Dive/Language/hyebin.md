# JAVA
### 1. JVM의 구조와 Java의 실행방식을 설명해주세요.
- JVM: Java 바이트코드를 실행하는 가상 머신
- JVM 구조 
  - Class Loader (클래스 로더): .class 파일(바이트코드)을 로딩하여 JVM 메모리에 올림
  - Execution Engine (실행 엔진): 로딩된 바이트코드를 실제 기계어로 변환하여 실행
    - 인터프리터
    - JIT 컴파일러
  - Runtime Data Area (런타임 메모리): JVM이 실행 중 사용하는 모든 메모리 공간
    - Method Area: 클래스 정보              
    - Heap: 객체
    - Stack: 호출 시 데이터
    - PC Register
    - Native Method Stack
  - Native Interface: Java에서 C/C++로 작성된 네이티브 메서드를 호출할 수 있게 해줌
  - Native Libraries: OS 레벨에서 사용하는 라이브러리(C/C++ 등)를 로드

- 실행 방식 
  - 작성: Java 소스코드 (.java)
  - 컴파일: javac 명령으로 바이트코드 (.class)로 컴파일됨 
    → 이때 기계어가 아닌 JVM이 이해할 수 있는 중간 형태로 변환됨 
  - 실행:
    - Execution Engine이 바이트코드를 인터프리팅 또는 JIT(Just-In-Time) 컴파일하여 실행
    - 이때 필요한 메모리는 Runtime Data Area에 적재됨
    
### 2. GC(Garbage Collection)가 무엇인지, 필요한 이유는 무엇인지, 동작방식에 대해 설명해주세요.
- Heap 메모리에서 더 이상 사용되지 않는 객체를 런타임 환경에서 자동으로 제거해주는 Java의 메모리 관리 기능

- 왜 필요한가? 
  - Java는 개발자가 메모리 해제를 직접 하지 않기 때문에, 불필요한 객체를 자동으로 정리하지 않으면 메모리 누수가 발생할 수 있음
  - 개발자는 비즈니스 로직에 집중, 메모리 관리는 JVM이 담당 

- 동작 방식 
  - Mark(표시) 단계
    - 루트(Root) 집합에서 시작하여 모든 도달 가능한(Reachable) 객체를 추적해 마크를 표시
    - 루트는 스택 변수, 정적 필드, 스레드, JNI 참조 등을 포함 
  - weep(스윕) 단계 
    - 힙 메모리를 순회하면서 마크되지 않은 객체를 '가비지'로 간주해 해제
  - Compact(압축) 단계 (선택적):
    - 일부 GC 알고리즘에서는 살아남은 객체들을 메모리의 한쪽으로 모아 메모리 단편화를 줄임

- GC 알고리즘 종류 (JVM에 따라 선택 가능)
  - Serial GC: 단일 스레드, 작은 애플리케이션에 적합 
  - Parallel GC: 멀티스레드로 처리, Throughput 중심 
  - CMS GC (Deprecated): 응답시간 단축 중심 
  - G1 GC: 대용량 Heap을 위한 점진적 GC 
  - ZGC, Shenandoah: 지연시간 최소화 (대규모 시스템에 적합)

### 3. 객체지향에 대해서 설명해주세요.
- 현실 세계의 객체를 추상화하여 소프트웨어로 모델링하는 개발 방법
- 원칙
  - 추상화: 객체의 핵심 속성과 동작만 모델링 (불필요한 것은 감춤)
  - 캡슐화: 데이터와 메서드를 하나로 묶고, 외부에 직접 접근을 제한 (private, getter/setter)
  - 상속: 부모 클래스의 속성과 기능을 자식 클래스가 물려받음 (재사용성 증가)
  - 다형성: 하나의 인터페이스나 메서드가 여러 동작을 수행할 수 있음 (오버라이딩, 오버로딩)
- 객체지향의 장점
  - 코드 재사용성 (상속)
  - 유지보수성 (모듈화)
  - 확장성 (다형성)
  - 직관적인 구조 (현실 세계와 유사)

 # 📅 2025/05/26
### 4. SOLID(객체지향 5대원칙)에 대해서 설명해주세요.
- 객체지향 설계의 5가지 원칙
- 유지보수성과 확장성을 높임
- 5대 원칙 
  - 단일 책임 원칙 (SRP) - 클래스는 하나의 책임만 가져야 합니다.
  - 개방-폐쇄 원칙 (OCP) - 확장엔 열려 있고 변경엔 닫혀 있어야 합니다.
  - 리스코프 치환 원칙 (LSP) - 자식 클래스는 부모 클래스를 대체할 수 있어야 합니다.
  - 인터페이스 분리 원칙 (ISP) - 인터페이스는 클라이언트가 사용하지 않는 메서드는 포함하지 않아야 합니다.
  - 의존 역전 원칙 (DIP) - 고수준 모듈은 저수준 모듈에 의존하면 안 되고, 둘 다 추상화에 의존해야 합니다.

### 5. 인터페이스와 추상클래스의 차이점에 대해 설명해주세요.

| 항목    | 인터페이스                             | 추상 클래스              |
| ----- | --------------------------------- | ------------------- |
| 다중 구현 | 가능                                | 불가능                 |
| 필드    | 상수만 가능                            | 변수, 상수 모두 가능        |
| 메서드   | 기본적으로 추상 (default, static 메서드 가능) | 일반 메서드 + 추상 메서드 가능  |
| 사용 목적 | 능력 부여 (역할 위주)                     | 공통 기능 추상화 (is-a 관계) |

### 6. 컬렉션 프레임워크에 대해서 설명해주세요.
- Java에서 데이터를 효율적으로 저장, 검색, 수정, 삭제할 수 있도록 제공하는 자료구조 모음
- 주요 인터페이스: List, Set, Map, Queue
- 주요 구현체: ArrayList, HashSet, HashMap, LinkedList, PriorityQueue

## 📅 2025/06/10
### 7. 오버라이딩과 오버로딩이 무엇이며 어떤 차이가 있을까요?
- 오버로딩: 같은 이름의 메서드를 여러 개 정의하되, 매개변수의 수나 타입이 다르게 작성 
  - 컴파일 타임에 어떤 메서드를 호출할지 결정됨

  | 사용 상황                                  | 예시                                                  |
  | -------------------------------------- | --------------------------------------------------- |
  | **비슷한 기능을 하는 메서드를 하나의 이름으로 제공하고 싶을 때** | `print(int)`, `print(String)`                       |
  | **유연하게 입력을 처리하고 싶을 때**                 | 생성자 오버로딩: `new Member()`, `new Member(String name)` |
  | **기본값 처리를 코드 레벨에서 하고 싶을 때**            | `findUser()` vs `findUser(String name)`             |

- 오버라이딩: 부모 메서드를 자식에서 재정의
  - 메서드 이름, 매개변수, 리턴 타입이 모두 같아야 함
  - 다형성(Polymorphism)을 구현하는 핵심 기술 

  | 사용 상황                                | 예시                                                  |
  | ------------------------------------ | --------------------------------------------------- |
  | **부모 클래스의 기본 동작을 자식에 맞게 수정하고 싶을 때**  | `toString()`, `equals()` 재정의                        |
  | **공통 인터페이스로 여러 객체를 동일하게 다루고 싶을 때**   | `Animal.sound()` → `Dog.sound()`, `Cat.sound()`     |
  | **프레임워크/라이브러리에서 제공하는 콜백 메서드를 구현할 때** | Spring에서 `@Controller` 클래스가 `handleRequest()` 오버라이딩 |

### 8. 동일성(identity)와 동등성(equality)에 대해 설명해주세요. (equals(), ==)
- ==: 주소 비교 (identity)
- .equals(): 내용 비교 (equality) 
  - Object에서 오버라이딩 가능

### 9. String, StringBuilder, StringBuffer 각각의 차이에 대해 설명해주세요.
- String
  - 불변(immutable) 객체이기 때문에 쓰레드 간 공유해도 안전
  - 예: String s = "a"; s.concat("b"); → "ab" 새로운 객체 생성

- StringBuilder
  - 가변(mutable)이고 동기화되지 않음
  - 멀티스레드 환경에서 동시에 사용하면 위험
  → 단일 쓰레드 환경 또는 성능이 중요한 경우 적합

- StringBuffer
  - 모든 메서드가 synchronized 키워드로 감싸져 있음
  - 멀티스레드 환경에서도 안전하게 사용 가능
  → 하지만 동기화 비용으로 성능 저하

- 쓰레드 안전(Thread-safe)?
  - 여러 개의 쓰레드가 동시에 같은 객체를 사용할 때, 그 객체가 "데이터 불일치나 오류 없이 안전하게 동작하는 상태"를 보장하는 것
    - 동시에 여러 쓰레드가 접근해도
    - 결과가 예측 가능하고
    - 문제가 발생하지 않는 코드 또는 객체