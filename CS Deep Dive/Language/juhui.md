1. JVM의 구조와 Java의 실행방식을 설명해주세요.
   JVM은 자바 애플리케이션이 실행되는 가상의 컴퓨터입니다. 자바는 플랫폼 독립적인 언어로 설계되었기 때문에 운영체제와 상관없이 실행이 가능해야합니다. 이를 위해 직접 기계어로 번역되지 않고 바이트코드라는 중간 언어로 컴파일 되고 이 바이트코드를 해석하고 실행하는 것이 JVM입니다.
   JVM의 구조는 크게 클래스 로더, 메모리 영역, 실행 엔진, Garbage Collector(GC), Native Interface의 5개로 구분할 수 있습니다.
   클래스 로더는 .class파일을 읽고 메모리에 적재합니다. 로딩 -> 링크 -> 초기화 단계를 거칩니다.
   메모리 영역은 JVM이 사용하는 메모리 공간으로 Method Area, Heap, Stack, PC Register, Native Method Stack으로 영역이 나뉩니다.
   실행 엔진은 바이트코드를 해석하고 명령을 실행합니다. 두 가지 방식으로 동작을 하는데 인터프리터 방식과 JIT 컴파일러를 함께 사용하여 실행합니다.
   GC는 Heap 영역에서 사용되지 않는 객체를 자동으로 정리하여 메모를 회수합니다.
   Native Interface는 Java 코드에서 운영체제나 C/C++라이브러리 같은 외부 코드와 연동할 수 있도록 도와줍니다.
2. GC(Garbage Collection)가 무엇인지, 필요한 이유는 무엇인지, 동작방식에 대해 설명해주세요.
   Garbage Collection(GC)은 프로그램 실행 중에 더 이상 사용되지 않는 메모리 영역의 객체들을 자동으로 찾아서 해제하는 기능을 말합니다.
   GC가 필요한 이유는 개발자가 직접 메모리를 관리하는 언어(C/C++ 등)에서는 메모리를 해제하지 않으면 누수가 발생하고, 이미 해제된 메모리를 접근하면 오류가 발생하는 등 메모리 문제가 많았습니다. 반면, 자바는 메모리를 자동으로 관리하는 방식으로, 개발자가 비즈니스 로직에 집중할 수 있도록 해 주며, 시스템 안정성도 향상시킵니다.
   GC의 동작 방식은 JVM 힙 메모리를 기준으로 동작합니다. 힙 영역은 크게 Young 영역과 Old 영역으로 나뉘며, 객체가 생성되면 먼저 Young 영역 중 Eden 공간에 저장됩니다. 일정 시간이 지나면 살아남은 객체는 Survivor 영역을 거쳐 Old 영역으로 이동합니다. GC는 이 과정에서 각각 Minor GC와 **Major GC(Full GC)**를 수행합니다. Minor GC는 Young 영역에서만 동작하며 짧고 빠르게 수행되는 반면, Major GC는 Old 영역 전체를 대상으로 하므로 성능에 영향을 줄 수 있습니다.

3. 객체지향에 대해서 설명해주세요.
   객체지향(Object-Oriented Programming, OOP)은 현실 세계의 개념을 객체 단위로 모델링하여 소프트웨어를 설계하고 구현하는 프로그래밍 패러다임입니다. 객체는 데이터(속성)와 이를 처리하는 동작(메서드)을 하나로 묶은 단위로, 객체들 간의 메시지 전달을 통해 프로그램이 실행됩니다.
   객체지향의 핵심 개념은 네 가지로 요약할 수 있습니다.
   첫째, **캡슐화(Encapsulation)**는 데이터를 외부에서 직접 접근하지 못하도록 감추고, 메서드를 통해서만 접근하도록 하여 정보은닉을 가능하게 합니다.
   둘째, **상속(Inheritance)**은 기존 클래스의 특성을 물려받아 새로운 클래스를 정의하는 개념으로, 코드 재사용성을 높이고 확장성을 제공합니다.
   셋째, **다형성(Polymorphism)**은 동일한 인터페이스로 다양한 구현체를 처리할 수 있도록 하여 코드의 유연성과 확장성을 높여줍니다.
   넷째, **추상화(Abstraction)**는 불필요한 세부사항은 감추고 핵심만을 모델링하여 복잡성을 줄입니다.
   객체지향은 유지보수와 확장에 유리하고, 모듈화가 잘 되기 때문에 팀 단위 협업에 적합하며, 실세계 모델링에도 직관적이라는 장점이 있습니다. 반면에 잘못 설계된 객체지향 구조는 오히려 복잡도를 높일 수 있으므로 클래스 간의 관계 설계와 책임 분리가 중요합니다.

   # 📅 2025/05/26

4. SOLID(객체지향 5대원칙)에 대해서 설명해주세요.
   SOLID원칙은 객체지향 설계에서 지켜야하는 5개의 소프트웨어 개발 원칙을 말합니다. 해당 원칙들을 적용하면 코드의 유지보수성, 확장성, 유연성을 높일 수 있습니다.

   - 단일 책임 원칙(Single Responsibility Principle)
     한 클래스가 하나의 역할만 가지도록 하여, 변경이 필요할 때 해당 클래스만 수정하면 되도록 설계하는 것입니다.

   - 개방 폐쇄 원칙(Open Closed Principle)
     기존 코드를 변경하지 않고도 기능을 확장할 수 있도록 만드는 원칙입니다. 이를 위해 인터페이스나 추상 클래슬르 적극적으로 활용합니다.

   - 리스코프 치환 원칙(Listov Substitutaion Prinsiple)
     부모 타입 객체를 자식 타입으로 치환해도 프로그램이 정상적으로 동작해야 한다는 원칙입니다. 이를 통해 상속의 올ㄹ바른 사용을 강조합니다.

   - 인터페이스 분리 원칙(Interface Segregation Principle)
     하나의 인터페이스가 너무 많은 기능을 가지지 않도록, 필요한 기능별로 인터페이스를 분리하는 원칙입니다. 불필요한 의존성을 줄이고, 필요한 기능만 구현할 수 있도록 합니다.

   - 의존 역전 원칙(Dependency Inversion Principle)
     고수준 모듈이 저수준 모듈에 직접 의존하지 않고, 추상화에 의존하게 함으로써 결합도를 낮추는 원칙입니다.

5. 인터페이스와 추상클래스의 차이점에 대해 설명해주세요.

   1. 상속 구조에서 차이
      추상클래스는 클래스이기 때문에 한 번만 상속이 가능하지만, 인터페이스는 여러 개를 동시에 구현할 수 있어 다중 구현이 가능합니다.

   2. 구현 여부
      추상클래스는 일부 메서드는 구현하고, 일부는 추상 메서드로 남겨둘 수 있습니다.
      반면, 인터페이스는 기본적으로 메서드의 시그니처만 선언하고, 구현은 하지 않습니다. 다만, Java 8부터는 default 메서드를 통해 일부 구현도 할 수 있습니다.

   3. 멤버 변수
      추상클래스는 인스턴스 변수 등 다양한 필드를 가질 수 있지만, 인터페이스는 상수(public static final)만 선언할 수 있습니다.

   정리하자면,
   공통 기능의 일부 구현이 필요하면 추상클래스, 다양한 타입의 동작을 명세하고 싶을 때는 인터페이스를 사용하는 것이 적합하다고 생각합니다.

6. 컬렉션 프레임워크에 대해서 설명해주세요.
   컬렉션 프레임워크는 자바에서 데이터를 효율적으로 저장하고 관리하기 위한 자료구조와 알고리즘을 제공하는 표준 라이브러리입니다.
   주요 인터페이스로는 List, Set, Map이 있습니다.

   - List
     순서가 있는 데이터의 집합으로, 중복을 허용합니다. 대표적으로 ArrayList, LinkedList가 있습니다.

   - Set
     중복을 허용하지 않는 집합이며, HashSet, TreeSet 등이 있습니다.

   - Map
     키와 값의 쌍으로 데이터를 저장하며, 키의 중복을 허용하지 않습니다. 대표적으로 HashMap, TreeMap 등이 있습니다.

   컬렉션 프레임워크는 각 자료구조에 맞는 다양한 구현체를 제공하여, 데이터의 저장, 검색, 삭제, 정렬 등을 효율적으로 처리할 수 있도록 지원합니다.
