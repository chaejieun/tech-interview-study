1. JVM의 구조와 Java의 실행방식을 설명해주세요.
   JVM은 자바 애플리케이션이 실행되는 가상의 컴퓨터입니다. 자바는 플랫폼 독립적인 언어로 설계되었기 때문에 운영체제와 상관없이 실행이 가능해야합니다. 이를 위해 직접 기계어로 번역되지 않고 바이트코드라는 중간 언어로 컴파일 되고 이 바이트코드를 해석하고 실행하는 것이 JVM입니다.
   JVM의 구조는 크게 클래스 로더, 메모리 영역, 실행 엔진, Garbage Collector(GC), Native Interface의 5개로 구분할 수 있습니다.
   클래스 로더는 .class파일을 읽고 메모리에 적재합니다. 로딩 -> 링크 -> 초기화 단계를 거칩니다.
   메모리 영역은 JVM이 사용하는 메모리 공간으로 Method Area, Heap, Stack, PC Register, Native Method Stack으로 영역이 나뉩니다.
   실행 엔진은 바이트코드를 해석하고 명령을 실행합니다. 두 가지 방식으로 동작을 하는데 인터프리터 방식과 JIT 컴파일러를 함께 사용하여 실행합니다.
   GC는 Heap 영역에서 사용되지 않는 객체를 자동으로 정리하여 메모를 회수합니다.
   Native Interface는 Java 코드에서 운영체제나 C/C++라이브러리 같은 외부 코드와 연동할 수 있도록 도와줍니다.
2. GC(Garbage Collection)가 무엇인지, 필요한 이유는 무엇인지, 동작방식에 대해 설명해주세요.
   Garbage Collection(GC)은 프로그램 실행 중에 더 이상 사용되지 않는 메모리 영역의 객체들을 자동으로 찾아서 해제하는 기능을 말합니다.
   GC가 필요한 이유는 개발자가 직접 메모리를 관리하는 언어(C/C++ 등)에서는 메모리를 해제하지 않으면 누수가 발생하고, 이미 해제된 메모리를 접근하면 오류가 발생하는 등 메모리 문제가 많았습니다. 반면, 자바는 메모리를 자동으로 관리하는 방식으로, 개발자가 비즈니스 로직에 집중할 수 있도록 해 주며, 시스템 안정성도 향상시킵니다.
   GC의 동작 방식은 JVM 힙 메모리를 기준으로 동작합니다. 힙 영역은 크게 Young 영역과 Old 영역으로 나뉘며, 객체가 생성되면 먼저 Young 영역 중 Eden 공간에 저장됩니다. 일정 시간이 지나면 살아남은 객체는 Survivor 영역을 거쳐 Old 영역으로 이동합니다. GC는 이 과정에서 각각 Minor GC와 **Major GC(Full GC)**를 수행합니다. Minor GC는 Young 영역에서만 동작하며 짧고 빠르게 수행되는 반면, Major GC는 Old 영역 전체를 대상으로 하므로 성능에 영향을 줄 수 있습니다.

3. 객체지향에 대해서 설명해주세요.
   객체지향(Object-Oriented Programming, OOP)은 현실 세계의 개념을 객체 단위로 모델링하여 소프트웨어를 설계하고 구현하는 프로그래밍 패러다임입니다. 객체는 데이터(속성)와 이를 처리하는 동작(메서드)을 하나로 묶은 단위로, 객체들 간의 메시지 전달을 통해 프로그램이 실행됩니다.
   객체지향의 핵심 개념은 네 가지로 요약할 수 있습니다.
   첫째, **캡슐화(Encapsulation)**는 데이터를 외부에서 직접 접근하지 못하도록 감추고, 메서드를 통해서만 접근하도록 하여 정보은닉을 가능하게 합니다.
   둘째, **상속(Inheritance)**은 기존 클래스의 특성을 물려받아 새로운 클래스를 정의하는 개념으로, 코드 재사용성을 높이고 확장성을 제공합니다.
   셋째, **다형성(Polymorphism)**은 동일한 인터페이스로 다양한 구현체를 처리할 수 있도록 하여 코드의 유연성과 확장성을 높여줍니다.
   넷째, **추상화(Abstraction)**는 불필요한 세부사항은 감추고 핵심만을 모델링하여 복잡성을 줄입니다.
   객체지향은 유지보수와 확장에 유리하고, 모듈화가 잘 되기 때문에 팀 단위 협업에 적합하며, 실세계 모델링에도 직관적이라는 장점이 있습니다. 반면에 잘못 설계된 객체지향 구조는 오히려 복잡도를 높일 수 있으므로 클래스 간의 관계 설계와 책임 분리가 중요합니다.
