1. CI(지속적 통합), 지속적 전달(Continuous Delivery), 지속적 배포(Continuous Deployment)의 차이는 무엇인가요? (각 개념의 정의와 차이점)

| 용어                                      | 정의                                                                             |
| --------------------------------------- | ------------------------------------------------------------------------------ |
| **CI (Continuous Integration)**         | 개발자가 작성한 코드를 **자주(하루에도 여러 번)** 통합하고, 통합 시 **자동으로 빌드/테스트**하여 문제를 조기에 발견하는 프로세스  |
| **CD - Continuous Delivery (지속적 전달)**   | CI 이후 단계를 포함해, **운영환경에 배포 가능한 상태**로 항상 유지하고, **사람이 배포 버튼만 누르면** 바로 배포될 수 있는 상태 |
| **CD - Continuous Deployment (지속적 배포)** | Continuous Delivery에 **자동 배포까지 포함**된 개념. 코드 변경이 **운영 환경까지 자동으로 배포**됨           |

| 항목     | CI (지속적 통합)                       | CD (지속적 전달)                     | CD (지속적 배포)                           |
| ------ | --------------------------------- | ------------------------------- | ------------------------------------- |
| 자동화 범위 | 빌드, 단위 테스트, 통합 테스트                | + 스테이징 배포까지                     | + 운영(프로덕션)까지 자동 배포                    |
| 배포 방식  | 수동                                | 수동 (1-클릭 배포 또는 승인 후 배포)         | 자동 (테스트 통과 시 운영 배포까지 자동)              |
| 배포 승인  | 필요 없음                             | 필요                              | 불필요                                   |
| 주된 목적  | 빠른 피드백, 통합 안정성 확보                 | 배포 리스크 최소화, 배포 준비 자동화           | 빠른 출시 주기, 완전 자동화된 파이프라인               |
| 예시 도구  | GitHub Actions, Jenkins, CircleCI | Spinnaker, ArgoCD, GitLab CI/CD | same + Kubernetes, AWS CodePipeline 등 |


2. RESTful API란 무엇이며, 하나의 리소스를 설계할 때 지켜야 할 베스트 프랙티스에는 무엇이 있는지 설명해주세요. (예: 엔드포인트 구성, HTTP 메서드/상태코드 활용, 버전 관리 등)
- REST API 설계 규칙
    1. URI는 정보의 자원을 표현해야한다. 
        - 리소스의 이름은 동사보다는 명사를 사용한다. ( GET, /getuserInfo (X), GET, /userinfo (O))
        - URI는 자원을 표현하는데 중점을 두어야하기 때문에 행위에 대한 표현이 들어가면 안된다.
    2. 리소스에 대한 행위는 HTTP METHOD로 표현한다.(GET, POST, PUT, DELETE)
        - URI에 리소스에 대한 행위 표현이 들어가지 않는대신, HTTP METHOD를 통해 대신한다.
    3. 슬래시 (/)는 계층 관계를 나타낸다.(자료구조표현)
        userdata/userinfo <br />
        userdata/userrank
    4. URI 마지막은 슬래시(/) 사용금지
    5. 하이픈 (-)은 URI의 가독성을 높이는데 사용한다.
        - 불가피하게 길어지는 URI가 되는 경우 하이픈을 붙여 가독성을 높인다.
    6. 언더바(_) 사용 지양 
        - 보기 어렵거나 밑줄 때문에 문자가 가려지기도 한다.
    7. URI의 경로에는 소문자가 적합하다. 가능하면 대문자는 사용하지 말자
    8. 파일 확장자는 URI에 포함하지 않는다.
        - REST API에서는 메시지 바디 내용의 포맷을 나타내기 위한 파일 확장자를 URI에 포함시키지 않는다.
        - Aceept Header안에 포맷을 표시하도록 한다.

3. 마이크로서비스 아키텍처(MSA)와 모놀리식 아키텍처의 장단점을 비교해보세요. (예: 배포/스케일링 유연성, 복잡도, 운영상의 어려움 등)
- 모놀리식: 하나의 코드베이스와 실행 파일로 구성된 통합된 애플리케이션 구조
- MSA: 기능을 작은 서비스 단위로 나누고, 각각 독립적으로 개발, 배포하는 아키텍처

| 항목           | **모놀리식 아키텍처**               | **마이크로서비스 아키텍처 (MSA)**                       |
| ------------ | --------------------------- | -------------------------------------------- |
| **구현 난이도**   | 비교적 단순, 빠른 개발 가능            | 복잡한 설계 및 통신 방식 필요 (REST, gRPC 등)             |
| **배포 유연성**   | 전체 재빌드 & 배포 필요              | 서비스 단위로 개별 배포 가능                             |
| **스케일링**     | 전체를 수평 확장해야 함               | 서비스 단위로 독립적인 스케일링 가능                         |
| **장애 전파**    | 하나의 장애가 전체 애플리케이션에 영향       | 한 서비스 장애가 전체 시스템에 영향 덜 줌 (단, 설계 중요)          |
| **개발 조직 구조** | 단일 팀이 전체 애플리케이션 관리          | 팀별로 도메인별 서비스 담당 가능 (조직 확장성 ↑)                |
| **테스트/디버깅**  | 단일 애플리케이션이라 전체 테스트와 디버깅이 쉬움 | 서비스 간 통신 등으로 인한 복잡한 테스트 필요                   |
| **기술 스택**    | 동일한 기술 스택 사용                | 각 서비스마다 다른 기술 스택 선택 가능 (예: Java + Python 혼용) |
| **운영/모니터링**  | 단일 로그 및 모니터링 시스템으로 운영 간단    | 각 서비스에 대한 분산 추적, 중앙화된 모니터링 필요                |
| **초기 개발 속도** | 빠름                          | 느림 (초기 설계와 분산 시스템 구축 필요)                     |
