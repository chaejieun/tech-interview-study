### 1. CI(지속적 통합), 지속적 전달(Continuous Delivery), 지속적 배포(Continuous Deployment)의 차이는 무엇인가요? (각 개념의 정의와 차이점)

| 용어                                      | 정의                                                                             |
| --------------------------------------- | ------------------------------------------------------------------------------ |
| **CI (Continuous Integration)**         | 개발자가 작성한 코드를 **자주(하루에도 여러 번)** 통합하고, 통합 시 **자동으로 빌드/테스트**하여 문제를 조기에 발견하는 프로세스  |
| **CD - Continuous Delivery (지속적 전달)**   | CI 이후 단계를 포함해, **운영환경에 배포 가능한 상태**로 항상 유지하고, **사람이 배포 버튼만 누르면** 바로 배포될 수 있는 상태 |
| **CD - Continuous Deployment (지속적 배포)** | Continuous Delivery에 **자동 배포까지 포함**된 개념. 코드 변경이 **운영 환경까지 자동으로 배포**됨           |

| 항목     | CI (지속적 통합)                       | CD (지속적 전달)                     | CD (지속적 배포)                           |
| ------ | --------------------------------- | ------------------------------- | ------------------------------------- |
| 자동화 범위 | 빌드, 단위 테스트, 통합 테스트                | + 스테이징 배포까지                     | + 운영(프로덕션)까지 자동 배포                    |
| 배포 방식  | 수동                                | 수동 (1-클릭 배포 또는 승인 후 배포)         | 자동 (테스트 통과 시 운영 배포까지 자동)              |
| 배포 승인  | 필요 없음                             | 필요                              | 불필요                                   |
| 주된 목적  | 빠른 피드백, 통합 안정성 확보                 | 배포 리스크 최소화, 배포 준비 자동화           | 빠른 출시 주기, 완전 자동화된 파이프라인               |
| 예시 도구  | GitHub Actions, Jenkins, CircleCI | Spinnaker, ArgoCD, GitLab CI/CD | same + Kubernetes, AWS CodePipeline 등 |


### 2. RESTful API란 무엇이며, 하나의 리소스를 설계할 때 지켜야 할 베스트 프랙티스에는 무엇이 있는지 설명해주세요. (예: 엔드포인트 구성, HTTP 메서드/상태코드 활용, 버전 관리 등)
- REST API 설계 규칙
    1. URI는 정보의 자원을 표현해야한다. 
        - 리소스의 이름은 동사보다는 명사를 사용한다. ( GET, /getuserInfo (X), GET, /userinfo (O))
        - URI는 자원을 표현하는데 중점을 두어야하기 때문에 행위에 대한 표현이 들어가면 안된다.
    2. 리소스에 대한 행위는 HTTP METHOD로 표현한다.(GET, POST, PUT, DELETE)
        - URI에 리소스에 대한 행위 표현이 들어가지 않는대신, HTTP METHOD를 통해 대신한다.
    3. 슬래시 (/)는 계층 관계를 나타낸다.(자료구조표현)
        userdata/userinfo <br />
        userdata/userrank
    4. URI 마지막은 슬래시(/) 사용금지
    5. 하이픈 (-)은 URI의 가독성을 높이는데 사용한다.
        - 불가피하게 길어지는 URI가 되는 경우 하이픈을 붙여 가독성을 높인다.
    6. 언더바(_) 사용 지양 
        - 보기 어렵거나 밑줄 때문에 문자가 가려지기도 한다.
    7. URI의 경로에는 소문자가 적합하다. 가능하면 대문자는 사용하지 말자
    8. 파일 확장자는 URI에 포함하지 않는다.
        - REST API에서는 메시지 바디 내용의 포맷을 나타내기 위한 파일 확장자를 URI에 포함시키지 않는다.
        - Aceept Header안에 포맷을 표시하도록 한다.

### 3. 마이크로서비스 아키텍처(MSA)와 모놀리식 아키텍처의 장단점을 비교해보세요. (예: 배포/스케일링 유연성, 복잡도, 운영상의 어려움 등)
- 모놀리식: 하나의 코드베이스와 실행 파일로 구성된 통합된 애플리케이션 구조
- MSA: 기능을 작은 서비스 단위로 나누고, 각각 독립적으로 개발, 배포하는 아키텍처

| 항목           | **모놀리식 아키텍처**               | **마이크로서비스 아키텍처 (MSA)**                       |
| ------------ | --------------------------- | -------------------------------------------- |
| **구현 난이도**   | 비교적 단순, 빠른 개발 가능            | 복잡한 설계 및 통신 방식 필요 (REST, gRPC 등)             |
| **배포 유연성**   | 전체 재빌드 & 배포 필요              | 서비스 단위로 개별 배포 가능                             |
| **스케일링**     | 전체를 수평 확장해야 함               | 서비스 단위로 독립적인 스케일링 가능                         |
| **장애 전파**    | 하나의 장애가 전체 애플리케이션에 영향       | 한 서비스 장애가 전체 시스템에 영향 덜 줌 (단, 설계 중요)          |
| **개발 조직 구조** | 단일 팀이 전체 애플리케이션 관리          | 팀별로 도메인별 서비스 담당 가능 (조직 확장성 ↑)                |
| **테스트/디버깅**  | 단일 애플리케이션이라 전체 테스트와 디버깅이 쉬움 | 서비스 간 통신 등으로 인한 복잡한 테스트 필요                   |
| **기술 스택**    | 동일한 기술 스택 사용                | 각 서비스마다 다른 기술 스택 선택 가능 (예: Java + Python 혼용) |
| **운영/모니터링**  | 단일 로그 및 모니터링 시스템으로 운영 간단    | 각 서비스에 대한 분산 추적, 중앙화된 모니터링 필요                |
| **초기 개발 속도** | 빠름                          | 느림 (초기 설계와 분산 시스템 구축 필요)                     |

## 📅 2025/05/29
### 4. SOLID 원칙이란 무엇이며, 각각의 원칙과 소프트웨어 유지보수성/유연성과의 관계를 설명해주세요.
- 각각의 원칙은 변경에 유연하고, 테스트 가능성을 높이며, 코드의 결합도를 낮춥니다.
- 1. SRP (단일 책임 원칙)
    - 각 클래스는 단 하나의 책임만 가져야 합니다.   
    - 예: 사칙연산 기능만 담당하는 계산 클래스 
- 2. OCP (개방-폐쇄 원칙)
    - 객체는 확장에 대해서는 개방적이고, 수정에 대해서는 폐쇄적이어야 합니다. 
    - 즉, 기능을 확장할 수 있어야 하며, 변경은 피해야 합니다. 
    - 예: 유닛 클래스의 이동 메서드에서 이동 패턴을 별도의 메서드로 분리하여 하위 클래스에서 구현 
- 3. LSP (리스코프 치환 원칙)
    - 자식 클래스는 부모 클래스를 대체할 수 있어야 합니다. 
    - 부모 클래스가 들어갈 자리에 자식 클래스를 넣어도 동작이 계획대로 이루어져야 합니다. 
- 4. ISP (인터페이스 분리 원칙)
    - 클라이언트가 사용하지 않는 메서드는 인터페이스에 포함시키면 안 됩니다. 
    - 인터페이스를 여러 개의 작은 인터페이스로 분리하여 각 클라이언트의 필요에 맞게 제공해야 합니다. 
- 5. DIP (의존성 역전 원칙)
    - 고수준 모듈은 저수준 모듈에 의존하지 않도록 해야 합니다. 
    - 두 모듈 모두 추상화에 의존해야 합니다. 
    - 예: 추상 인터페이스를 통해 고수준 모듈이 저수준 모듈을 사용하도록 함으로써, 고수준 모듈이 구체적인 구현에 묶이지 않도록 함 

### 5. 합성(Composition)과 상속(Inheritance)의 차이를 설명하고, 각각을 어떤 상황에서 사용하는 것이 적절한지 이야기해주세요.
- 상속: 자식 클래스가 부모 클래스의 속성과 메소드를 물려받음
- 합성: 다른 클래스의 객체를 필드로 포함하고, 필요한 기능을 위임(delegate) 하는 구조

| 항목     | 합성 (Composition) | 상속 (Inheritance) |
| ------ | ---------------- | ---------------- |
| 관계     | has-a            | is-a             |
| 유연성    | 높음 (런타임 교체 가능)   | 낮음               |
| 캡슐화    | 잘 지켜짐  -> 객체 내부에 포함된 클래스를 사용하되, 인터페이스만 사용하고 구현은 감춤           | 깨지기 쉬움 -> 상속을 받으면 부모 클래스의 public, protected 필드/메서드에 접근 가능
           |
| 적절한 상황 | 동작 위임, 전략 변경     | 공통 로직 재사용        |

### 6. 단위 테스트(Unit Test), 통합 테스트(Integration Test), 기능 테스트(Functional Test) 각각의 차이와 목적은 무엇인가요?
| 유형     | 목적                | 범위 |
| ------ | ----------------- | -- |
| 단위 테스트 | 개별 함수/클래스 테스트     | 작음 |
| 통합 테스트 | 모듈 간 상호작용 테스트     | 중간 |
| 기능 테스트 | 요구사항 단위로 전체 기능 검증 | 큼  |

## 📅 2025/06/13
### 7. Heap 메모리는 언제 사용하나요?
- 런타임 중 동적으로 객체를 저장하는 메모리 영역
- JVM에서는 new 키워드로 생성한 객체가 Heap에 저장됨
- 사용되는 상황 
    | 상황                       | 예시                                           |
    | ------------------------ | -------------------------------------------- |
    | ✅ 객체 생성 시                | `new Member()` → 객체는 Heap에 저장                |
    | ✅ 가변 크기 데이터 할당           | 배열, 컬렉션 (`new int[1000]`, `new ArrayList<>`) |
    | ✅ 참조를 여러 곳에서 공유할 때       | 한 객체를 여러 클래스에서 참조                            |
    | ✅ 긴 생명 주기의 데이터           | 스레드보다 오래 살아야 하는 데이터, 캐시 등                    |
    | ✅ 클래스 멤버(필드)에 저장되는 인스턴스들 | 클래스 내 인스턴스 변수는 객체 생성 시 Heap에 할당됨             |

### 8. Git에서 merge와 rebase의 차이는 무엇이며, 각각을 언제 사용하는 것이 적절한가요?
- merge: 두 개의 브랜치를 합치는 방식
    - 기존 히스토리를 유지하면서 새로운 "병합 커밋"을 생성
    - 특징 
        - 히스토리 보존 (브랜치의 작업 흐름이 그대로 남음)
        - 협업에 적합 (누가 어떤 작업을 했는지 명확함)
        - 커밋 기록이 복잡해질 수 있음
    - 사용 상황
        - 여러 사람과 협업 시
        - main 브랜치에 feature 브랜치를 병합할 때
        - 충돌이 생겨도 추적이 용이함
- rebase: 브랜치 기반을 변경해서 커밋을 "다시 쓰는" 방식
    - 히스토리를 직선화하여 더 깔끔한 커밋 로그 생성
    - 특징
        - 히스토리 정리에 유리 (중간 병합 커밋 없이 직선적 흐름)
        - merge보다 커밋 로그가 간결함
        - 협업 중에는 주의가 필요 (강제 푸시 발생 가능)
    - 사용 상황
        - 개인 브랜치에서 깔끔한 커밋 히스토리 정리 시
        - pull 전에 rebase → 최신 코드 기반으로 테스트
        - 팀에 merge 기준이 있는 경우, push 전에 정리용으로 사용

### 9. 트랜잭션의 ACID 특성이란 무엇이며, 각각(원자성, 일관성, 격리성, 지속성)이 의미하는 바는 무엇인가요?
| 항목                        | 의미             | 설명                                                                               |
| ------------------------- | -------------- | -------------------------------------------------------------------------------- |
| **A - Atomicity (원자성)**   | 전부 성공 또는 전부 실패 | 하나의 트랜잭션 내 모든 작업은 **한 덩어리**로 실행되어야 함<br> → 중간에 하나라도 실패하면 전체 롤백                   |
| **C - Consistency (일관성)** | 일관된 상태 유지      | 트랜잭션 전후로 DB는 **정합성 있는 상태**를 유지해야 함<br> → 제약조건, 무결성 위반 불가                         |
| **I - Isolation (격리성)**   | 트랜잭션 간 간섭 방지   | 여러 트랜잭션이 동시에 수행될 때 **각각 독립적으로 수행**되어야 함<br> → Dirty Read, Non-repeatable Read 방지 |
| **D - Durability (지속성)**  | 커밋 후에는 영구 저장   | 트랜잭션이 성공적으로 커밋되면, 그 결과는 **시스템 장애가 발생해도 보존**되어야 함 (로그, 디스크 등 활용)                  |
