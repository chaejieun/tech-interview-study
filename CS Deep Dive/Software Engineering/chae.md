# 📅 2025/05/15
# CI(지속적 통합), 지속적 전달(Continuous Delivery), 지속적 배포(Continuous Deployment)의 차이는 무엇인가요? (각 개념의 정의와 차이점)

## CI (Continuous Integration)
- 빌드/테스트 자동화 과정. CI는 개발자를 위한 자동화 프로세스인 **지속적 통합(Contiunos Integration)**을 의미. 
- 지속적 통합의 실행은 소스/버전 관리 시스템에 대한 변경 사항을 정기적으로 커밋하여 모든 사람에게 동일 작업 기반을 제공하는 것.
- 커밋할 떄마다 빌드와 일련의 자동 테스트가 이뤄져 동작을 확인하고 변경으로 인해 문제가 생기는 부분이 없도록 보장.

## CD (Continuous Delivery) 
- CI 이후, **프로덕션 외 환경(스테이징 등)에 자동 배포**까지 진행하는 프로세스
- 배포를 언제든지 버튼 한 번으로 안정적으로 할 수 있도록 준비된 상태 유지.


## CD (Continuous Deployment)
- **프로덕션 배포 단계를 자동화**하는 DevOps 방식을 논리적 극한으로 끌어올린다.
- 코드 변경이 파이프라인의 이전 단계를 모두 성공적으로 통과하면 수동 개입 없이 해당 변경 사항이 프로덕션에 자동으로 배포.
- 지속적 배포를 채택하면 품질 저하 없이 최대한 빨리 사용자에게 새로운 기능을 제공할 수 있음.

--- 

# RESTful API란 무엇이며, 하나의 리소스를 설계할 때 지켜야 할 베스트 프랙티스에는 무엇이 있는지 설명해주세요. (예: 엔드포인트 구성, HTTP 메서드/상태코드 활용, 버전 관리 등)

# RESTful한 리소스 설계 시 Best Practice
1. URI 설계
-  명사(리소스) 기반 (동사 X)  ex) /orders, /users 사용
-  동사(액션) 사용 자제 ex)/create-order 자제
-  파일 확장자 포함 금지 ex ).json, .xml 금지

2. HTTP 메소드 활용
### CRUD 연산 매핑
- `GET`: 리소스 조회, 리소스 컬렉션 조회
- `POST`: 리소스 생성
- `PUT` : 리소스를 완전히 대체
- `PATCH` : 리소스의 일부를 변경
- `DELETE` : 리소스를 삭제

### HTTP 상태 코드 사용
| 상태 코드 | 의미                    | 예시 상황                     |
| ----- | --------------------- | ------------------------- |
| 200   | OK                    | 조회 성공, 삭제 성공              |
| 201   | Created               | 리소스 생성 성공                 |
| 204   | No Content            | 성공했으나 반환할 컨텐츠 없음 (DELETE) |
| 400   | Bad Request           | 잘못된 요청 파라미터               |
| 401   | Unauthorized          | 인증 필요                     |
| 403   | Forbidden             | 접근 권한 없음                  |
| 404   | Not Found             | 리소스 없음                    |
| 409   | Conflict              | 중복 리소스 생성 요청              |
| 500   | Internal Server Error | 서버 에러                     |


3. 리소스 표현
- 리턴 값: 리소스 생성 또는 수정 시, 새 리소스 표현 또는 수정된 리소스 표현을 반환
- 하위 리소스: 리소스를 표현할 때 하위 리소스에 대한 링크를 포함할 수 있습니다. 예를 들어, 사용자를 조회할 때 사용자에게 관련된 주문 리소스에 대한 링크를 포함할 수 있습니다. 
- Content-Type 명시: 응답에 포함되는 데이터의 형식(예: application/json, application/xml)을 Content-Type 헤더에 명시

### ✨ 추가 질문 포인트
#### 조회의 경우 POST를 사용 못하나요? 
- 복잡한 쿼리 조건 전달이 필요할 때 / 보안 또는 민감한 데이터를 포함할 때(주민번호,토큰) / 검색 요청 로그를 남기거나 기록성 요청일 때

--- 

## 마이크로서비스 아키텍처(MSA)와 모놀리식 아키텍처의 장단점을 비교해보세요. (예: 배포/스케일링 유연성, 복잡도, 운영상의 어려움 등)

### 모놀리식 아키텍처(Monolithic Architecture, MA)
- 하나의 통합된 코드 베이스로 여러 비즈니스 기능을 수행하는 전통적인 소프트웨어 개발 모델. **단일 애플리케이션 내에 서비스의 모든 로직이 통으로 들어가 있는 구조**
-  중앙 집중된 구조이기 때문에 분산된 애플리케이션에 비해 엔드 투 엔드 테스트(End-to-End, E2E: 사용자 관점에서 애플리케이션의 흐름을 처음부터 끝까지 테스트하는 것)를 더 빠르게 수행할 수 있다


### 모놀리식 아키텍처(Monolithic Architecture, MA) 장점
- 단순하고 통일성 있는 구조
- 단일 코드베이스 -> 간편한 개발 
- 빠르고 편한 E2E 테스트
- 손쉬운 모니터링, 디버깅

### 모놀리식 아키텍처(Monolithic Architecture, MA) 단점
- 유지 보수 및 안정성 문제
- 느린 개발 및 배포 속도
- 위축된 확장성
- 기술 유연성 낮음 (스택 제한)

### 모놀리식 아키텍처(Monolithic Architecture, MA) 적합한 경우?
- 기술적 복잡도가 낮은 소규모 프로젝트
- MVP 수준의 단일 비즈니스 또는 신설 도메인 등
- 시장 진입을 위해 빠르고 간편하게 기능 개발 및 배포를 수행해야 할 때


### 마이크로서비스 아키텍처(MicroService Architecture, MSA)
- 서비스를 아주 작은 서비스(Microservice) 단위로 나눠 **각 서비스에서 독립적으로 서비스를 구성하는 모델** 
- 중앙 집중적인 관리 체계 대신 경량화된 API나 메세지로 직접 통신하며 접근하는 방식
- 배포가 빠르고 잦은 만큼 애자일 작업 방식을 취하기도 편리
- 일부분에 문제가 생기면 시스템 전체가 다운될 수 있는 모놀리식 아키텍처와 달리, 한 서비스가 다운되더라도 다른 서비스는 문제없이 작동 가능
- 자체 DB를 서비스마다 가지고 있어서 데이터 무결성을 유지하는 데도 도움


### 마이크로서비스 아키텍처(MicroService Architecture, MSA) 장점
- 유연한 확장성
- 더 민첩한 배포 주기
- 유지 관리 안정성
- 기술 유연성 높음(서비스별 독립적인 스택 선정 가능)

### 마이크로서비스 아키텍처(MicroService Architecture, MSA) 단점
- 복잡한 구조, 높은 구현 난이도
- 모니터링, 디버깅, 통합 테스트가 어려움
- 인프라 및 자원, 인력에 드는 막대한 비용
- 까다로운 DB 트랜잭션 관리

### 마이크로서비스 아키텍처(MicroService Architecture, MSA) 적합한 경우?
- 기술적 복잡도가 높은 대규모 프로젝트
- 다양한 기술 스택을 사용하고, 여러 비즈니스별 요구사항이 명확한 경우
- 장애를 줄이고 시스템 전체의 가용성과 탄력성을 높여야 할 때