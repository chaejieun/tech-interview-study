# 📅 2025/05/15
# CI(지속적 통합), 지속적 전달(Continuous Delivery), 지속적 배포(Continuous Deployment)의 차이는 무엇인가요? (각 개념의 정의와 차이점)

## CI (Continuous Integration)
- 빌드/테스트 자동화 과정. CI는 개발자를 위한 자동화 프로세스인 **지속적 통합(Contiunos Integration)**을 의미. 
- 지속적 통합의 실행은 소스/버전 관리 시스템에 대한 변경 사항을 정기적으로 커밋하여 모든 사람에게 동일 작업 기반을 제공하는 것.
- 커밋할 떄마다 빌드와 일련의 자동 테스트가 이뤄져 동작을 확인하고 변경으로 인해 문제가 생기는 부분이 없도록 보장.

## CD (Continuous Delivery) 
- CI 이후, **프로덕션 외 환경(스테이징 등)에 자동 배포**까지 진행하는 프로세스
- 배포를 언제든지 버튼 한 번으로 안정적으로 할 수 있도록 준비된 상태 유지.


## CD (Continuous Deployment)
- **프로덕션 배포 단계를 자동화**하는 DevOps 방식을 논리적 극한으로 끌어올린다.
- 코드 변경이 파이프라인의 이전 단계를 모두 성공적으로 통과하면 수동 개입 없이 해당 변경 사항이 프로덕션에 자동으로 배포.
- 지속적 배포를 채택하면 품질 저하 없이 최대한 빨리 사용자에게 새로운 기능을 제공할 수 있음.

--- 

# RESTful API란 무엇이며, 하나의 리소스를 설계할 때 지켜야 할 베스트 프랙티스에는 무엇이 있는지 설명해주세요. (예: 엔드포인트 구성, HTTP 메서드/상태코드 활용, 버전 관리 등)

# RESTful한 리소스 설계 시 Best Practice
1. URI 설계
-  명사(리소스) 기반 (동사 X)  ex) /orders, /users 사용
-  동사(액션) 사용 자제 ex)/create-order 자제
-  파일 확장자 포함 금지 ex ).json, .xml 금지

2. HTTP 메소드 활용
### CRUD 연산 매핑
- `GET`: 리소스 조회, 리소스 컬렉션 조회
- `POST`: 리소스 생성
- `PUT` : 리소스를 완전히 대체
- `PATCH` : 리소스의 일부를 변경
- `DELETE` : 리소스를 삭제

### HTTP 상태 코드 사용
| 상태 코드 | 의미                    | 예시 상황                     |
| ----- | --------------------- | ------------------------- |
| 200   | OK                    | 조회 성공, 삭제 성공              |
| 201   | Created               | 리소스 생성 성공                 |
| 204   | No Content            | 성공했으나 반환할 컨텐츠 없음 (DELETE) |
| 400   | Bad Request           | 잘못된 요청 파라미터               |
| 401   | Unauthorized          | 인증 필요                     |
| 403   | Forbidden             | 접근 권한 없음                  |
| 404   | Not Found             | 리소스 없음                    |
| 409   | Conflict              | 중복 리소스 생성 요청              |
| 500   | Internal Server Error | 서버 에러                     |


3. 리소스 표현
- 리턴 값: 리소스 생성 또는 수정 시, 새 리소스 표현 또는 수정된 리소스 표현을 반환
- 하위 리소스: 리소스를 표현할 때 하위 리소스에 대한 링크를 포함할 수 있습니다. 예를 들어, 사용자를 조회할 때 사용자에게 관련된 주문 리소스에 대한 링크를 포함할 수 있습니다. 
- Content-Type 명시: 응답에 포함되는 데이터의 형식(예: application/json, application/xml)을 Content-Type 헤더에 명시

### ✨ 추가 질문 포인트
#### 조회의 경우 POST를 사용 못하나요? 
- 복잡한 쿼리 조건 전달이 필요할 때 / 보안 또는 민감한 데이터를 포함할 때(주민번호,토큰) / 검색 요청 로그를 남기거나 기록성 요청일 때

--- 

## 마이크로서비스 아키텍처(MSA)와 모놀리식 아키텍처의 장단점을 비교해보세요. (예: 배포/스케일링 유연성, 복잡도, 운영상의 어려움 등)

### 모놀리식 아키텍처(Monolithic Architecture, MA)
- 하나의 통합된 코드 베이스로 여러 비즈니스 기능을 수행하는 전통적인 소프트웨어 개발 모델. **단일 애플리케이션 내에 서비스의 모든 로직이 통으로 들어가 있는 구조**
-  중앙 집중된 구조이기 때문에 분산된 애플리케이션에 비해 엔드 투 엔드 테스트(End-to-End, E2E: 사용자 관점에서 애플리케이션의 흐름을 처음부터 끝까지 테스트하는 것)를 더 빠르게 수행할 수 있다


### 모놀리식 아키텍처(Monolithic Architecture, MA) 장점
- 단순하고 통일성 있는 구조
- 단일 코드베이스 -> 간편한 개발 
- 빠르고 편한 E2E 테스트
- 손쉬운 모니터링, 디버깅

### 모놀리식 아키텍처(Monolithic Architecture, MA) 단점
- 유지 보수 및 안정성 문제
- 느린 개발 및 배포 속도
- 위축된 확장성
- 기술 유연성 낮음 (스택 제한)

### 모놀리식 아키텍처(Monolithic Architecture, MA) 적합한 경우?
- 기술적 복잡도가 낮은 소규모 프로젝트
- MVP 수준의 단일 비즈니스 또는 신설 도메인 등
- 시장 진입을 위해 빠르고 간편하게 기능 개발 및 배포를 수행해야 할 때


### 마이크로서비스 아키텍처(MicroService Architecture, MSA)
- 서비스를 아주 작은 서비스(Microservice) 단위로 나눠 **각 서비스에서 독립적으로 서비스를 구성하는 모델** 
- 중앙 집중적인 관리 체계 대신 경량화된 API나 메세지로 직접 통신하며 접근하는 방식
- 배포가 빠르고 잦은 만큼 애자일 작업 방식을 취하기도 편리
- 일부분에 문제가 생기면 시스템 전체가 다운될 수 있는 모놀리식 아키텍처와 달리, 한 서비스가 다운되더라도 다른 서비스는 문제없이 작동 가능
- 자체 DB를 서비스마다 가지고 있어서 데이터 무결성을 유지하는 데도 도움


### 마이크로서비스 아키텍처(MicroService Architecture, MSA) 장점
- 유연한 확장성
- 더 민첩한 배포 주기
- 유지 관리 안정성
- 기술 유연성 높음(서비스별 독립적인 스택 선정 가능)

### 마이크로서비스 아키텍처(MicroService Architecture, MSA) 단점
- 복잡한 구조, 높은 구현 난이도
- 모니터링, 디버깅, 통합 테스트가 어려움
- 인프라 및 자원, 인력에 드는 막대한 비용
- 까다로운 DB 트랜잭션 관리

### 마이크로서비스 아키텍처(MicroService Architecture, MSA) 적합한 경우?
- 기술적 복잡도가 높은 대규모 프로젝트
- 다양한 기술 스택을 사용하고, 여러 비즈니스별 요구사항이 명확한 경우
- 장애를 줄이고 시스템 전체의 가용성과 탄력성을 높여야 할 때


---

# 📅 2025/05/29
# SOLID 원칙이란 무엇이며, 각각의 원칙과 소프트웨어 유지보수성/유연성과의 관계를 설명해주세요.

## 1. Single Responsibility Principle (SRP): 단일 책임 원칙
- 하나의 클래스는 오직 하나의 책임, 즉 하나의 변경 이유만을 가져야 합니다. 만약 클래스가 여러 책임을 가지게 되면, 하나의 책임을 변경할 때 다른 책임에 영향을 줄 가능성이 높아집니다.
- 유지보수성 향상 : 클래스가 하나의 책임만 가지므로, 해당 책임의 변경 사항이 다른 부분에 미치는 영향이 적어짐. 따라서, 특정 기능을 수정하거나 버그를 해결할 대 다른 코드 부분을 건드릴 위험이 줄어들어 유지보수가 쉬어진다.
- 유연성 증대 : 각 책임이 분리되어 있으므로, 특정 기능을 변경하거나 새로운 기능을 추가할 때 기존 코드에 미치는 영향을 최소화하면서 독립적으로 작업할 수 있다. 

## 2. Open/Closed Principle (OCP): 개방-폐쇄 원칙
- 기존 코드를 수정하지 않고도 기능을 확장할 수 있도록 설계해야 한다. 이는 추상화와 다형성을 통해 달성할 수 있다
- 유지보수성 향상 : 기존 코드를 수정하지 않고 새로운 기능을 추가할 수 있으므로, 이미 테스트 되고 안정화된 코드를 건드릴 필요가 없어 잠재적인 버그 발생 위험을 줄인다.
- 유연성 증대 : 새로운 요구사항이 발생했을 때, 기존 코드를 변경하는 대신 새로운 클래스를 추가하여 기능을 확장할 수 있다. 이는 시스템을 더욱 유연하게 만들어 변화에 쉽게 대응할 수 있도록 한다.

## 3. Liskov Substitution Principle (LSP): 리스코프 치환 원칙
- 부모 클래스의 인스턴스를 사용하는 코드에서 자식 클래스의 인스턴스로 대체해도 프로그램의 정확성이 깨지지 않아야 한다. 즉, 서브타입은 슈퍼타입의 행위를 보존해야 한다.
- 유지보수성 향상 : 상위 타입의 인터페이스를 따르는 하위 타입은 언제든지 교체 가능하므로, 코드의 일관성을 유지하고 예측 가능성을 높여 유지보수를 용이하게 한다.
- 유연성 증대 : 다형성을 활용하여 다양한 하위 타입의 객체를 일관된 방식으로 처리할 수 있게 되어 코드의 재사용을 높이고, 새로운 하위 타입을 쉽게 추가할 수 있어 시스템의 유연성을 향상시킨다.

## 4. Interface Segregation Principle (ISP): 인터페이스 분리 원칙
- 하나의 거대한 인터페이스 대신, 클라이언트에게 필요한 메소드만을 제공하는 여러 개의 작은 인터페이스로 분리해야 한다.
- 유지보수성 향상 : 불필요한 메소드에 의존하지 않으므로, 특정 인터페이스의 변경이 다른 클라이언트에 미치는 여향을 최소화하여 시스템의 안정성을 높이고 유지보수를 용이하게 한다.
- 유연성 증대 : 각 클라이언트에 필요한 인터페이스만 제공함으로써 시스템의 결합도를 낮추고, 각 컴포넌트가 독립적으로 변화하고 발전할 수 있도록 하여 유연성을 높인다.

## 5. Dependency Inversion Principle (DIP): 의존성 역전 원칙
- 구체적인 구현에 의존하는 대신, 추상화(인터페이스나 추상 클래스)에 의존하도록 설계해야 한다. 이를 통해 고수준 모듈과 저수준 모듈 사이의 결합도를 낮출 수 있다
- 유지보수성 향상 : 고수준 모듈이 저수준 모듈의 구체적인 구현에 의존하지 않으므로, 저수준 모듈의 변경이 고수준 모듈에 미치는 영향을 줄여 유지보수를 용이하게 한다
- 유연성 증대 : 추상화에 의존함으로써 다양한 구현체를 쉽게 교체하거나 확장할 수 있게 되어 시스템의 유연성을 높인다. 또한, 단위테스트를 용이하게 만들어 코드의 품질을 향상시키는 데 도움이 된다.

<br>

# 합성(Composition)과 상속(Inheritance)의 차이를 설명하고, 각각을 어떤 상황에서 사용하는 것이 적절한지 이야기해주세요.

# 상속(Inheritance) : IS-A 관계
- 상속은 한 클래스가 다른 클래스의 속성과 메소드를 물려받는 것. 하위 클래스는 상위 클래스의 특성을 포함하며, 필요에 따라 새로운 속성이나 메소드를 추가하거나 기존의 것을 오버라이드(override)할 수 있다. 
- A는 B이다 (IS-A) 관계를 모델링하는 데 적합

## 상속의 특징
- 강한 결합(tight coupling) : 하위 클래스는 상위 클래스에 강하게 의존하게 된다. 상위 클래스의 변경은 하위 클래스에 영향을 미칠 수 있다.
- 코드 재사용 용이 : 상위 클래스의 기능을 그대로 물려받아 코드 중복을 줄일 수 있다
- 컴파일 타임 관계 : 상속 관계는 컴파일 시점에 결정

# 합성(Composition) : HAS-A 관계
- 합성은 한 클래스의 인스턴스를 다른 클래스의 속성으로 포함시켜 기능을 재사용하는 방식.  
- A는 B를 가진다(HAS-A) 관계를 모델링하는데 적합하다

## 합성의 특징
- 느슨한 결합(loose coupling) : 포함하는 클래스는 포함되는 클래스에 대한 직접적인 의존성이 적다. 포함되는 클래스의 변경이 포함하는 클래스에 미치는 영향이 상대적으로 적다
- 유연성 증대 : 실행 시간에 객체의 구성을 동적으로 변경할 수 있다
- 코드 재사용 및 조합 용이 : 여러 객체의 기능을 조합하여 더 복잡한 기능을 구현할 수 있다

## 상속이 적절한 경우
1. 클래스 간에 명확한 "IS-A" 관계가 존재할 때 (예: 개는 동물이다).
2. 상위 클래스의 인터페이스를 하위 클래스가 그대로 확장하고 싶을 때.
3. 기존 클래스의 기본 동작을 크게 변경하지 않고 일부 특성을 특화하고 싶을 때.
4. 클래스 계층 구조가 비교적 안정적일 때.

## 합성이 적절한 경우
1. 클래스 간에 "HAS-A" 관계가 더 자연스러울 때 (예: 자동차는 엔진을 가진다).
2. 코드 재사용보다는 유연성과 낮은 결합도를 중요시할 때.
3. 실행 시간에 객체의 행동을 동적으로 변경하고 싶을 때 (전략 패턴 등).
4. 다양한 기능들을 조합하여 새로운 기능을 만들고 싶을 때.

<br>

# 단위 테스트(Unit Test), 통합 테스트(Integration Test), 기능 테스트(Functional Test) 각각의 차이와 목적은 무엇인가요?
## 단위 테스트(Unit Test)
- 개별적인 가장 작은 코드 단위(함수, 메소드, 클래스 등)
- 각 코드 단위가 **독립적으로** 정확하게 동작하는 지 검증. 외부 의존성(데이터베이스, 다른 모듈 등)은 보통 Mocking 또는 Stubbing을 사용하여 격리한다.

## 통합 테스트(Integration Test)
- 둘 이상의 **통합된** 컴포넌트 또는 모듈 간의 상호작용
- 여러 컴포넌트가 함께 올바르게 작동하는 지, 데이터가 정확하게 교환되는 지, 상호작용에 문제가 없는 지 검증

## 기능 테스트(Functional Test)
- **최종 사용자의 관점**에서 시스템의 특정 기능 전체
- 소프트웨어가 명세된 요구사항을 충족하는 지, 특정 입력에 대해 예상된 출력을 내는 지 검증. 
- 내부 구현 방식은 고려하지 않고 **결과**에 초점을 맞춘다.