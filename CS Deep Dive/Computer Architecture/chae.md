# 📅 2025/04/30
# 컴퓨터의 구성 5가지에 대해 설명해주세요.
- 입력장치(Input Unit) : 사용자의 데이터를 컴퓨터에 전달하는 장치 ex) 키보드, 마우스, 스캐너 
- 출력장치(Output Unit) : 처리된 데이터를 사용자에게 보여주는 장치 ex) 모니터, 프린터, 스피커
- 중앙처리장치(CPU) : 컴퓨터의 두뇌, 제어장치와 연산장치로 구성
- 기억장치(Storage Unit) : 데이터를 저장하는 장치. 주기억장치(RAM), 보조기억장치(HDD, SSD)로 나뉨
- 제어장치(Control Unit) : 명령을 해석하고 각 구성요소의 동작을 지시함. CPU의 일부 
- 연산장치(ALU) : 산술 및 논리 연산을 수행. CPU의 일부

---

### ✨ 정리 포인트
- 사용자가 키보드를 통해 데이터를 입력하면, 입력장치를 통해 정보가 CPU로 전달되고, CPU의 제어장치와 연산장치가 이를 처리한 뒤, 처리된 결과는 메모리에 저장되거나 출력장치를 통해 사용자에게 제공된다.
- 입력 -> 처리 -> 저장 -> 출력의 사이클 방식

---
---
---

# 중앙처리장치(CPU) 작동 원리에 대해 설명해주세요.
- 중앙처리장치는 명령어의 해석과 자료의 연산, 비교등의 처리를 제어하는 컴퓨터 시스템의 핵심 장치
- 다양한 입력 장치로부터 정보를 입력받아 처리한 후, 그 결과를 출력장치로 보내는 일련의 과정을 제어하고 조정하는 일을 수행
- CPU는 사람의 두뇌와 같이 컴퓨터의 모든 시스템을 제어, 처리하는 가장 핵심적인 장치라고 할 수 있다


## CPU의 구성요소
1. 제어장치(Control Unit, CU) : 컴퓨터 시스템의 작동을 통제하고 지시하는 장치
- 기억 장치로부터 프로그램 명령을 순차적으로 꺼내 해독하고, 해석에 따라서 명령어 실행에 필요한 제어 신호를 기억장치, 연산장치 등으로 보낸다.

2. 연산장치(Arithmetic Logic Unit, ALU) : 명령어를 실행하기 위한 마이크로 연산을 수행하는 장치
- 연산에 필요한 자료를 입력받아 산술, 논리, 관계, 이동 등 다양한 연산을 수행
- 연산에 필요한 데이터는 레지스터에서 가져오고 연산이 끝나면 다시 레지스터로 돌려준다


3. 레지스터(Register) : CPU 내에 있는 고속 기억 장치
- 명령어 주소, 코드, 연산에 필요한 데이터 연산 결과 등을 임시 저장
- 레지스터는 메모리 계층의 최상위에 위치하며 가장 빠른 속도로 접근 가능한 메모리
- 용도에 따라 범용 레지스터와 특수 목적 레지스터로 구분


--- 
## CPU의 연산
1. Fetch(인출) : 메모리상의 프로그램 카운터(PC)가 가리키는 명령어를 CPU로 인출하여 적재 
2. Decode(해석) : 명령어의 종류와 타겟 등을 해석하여 결정
3. Execute(실행) : 해석된 명령어에 따라 데이터에 대한 연산 수행
4. Writeback(쓰기) : 수행 완료된 데이터를 메모리에 기록

--- 

### ✨ 정리 포인트
- CPU는 컴퓨터의 중앙처리장치로, 모든 연산과 제어 흐름을 담당하는 핵심 부품. 사람의 두뇌처럼 작동하며, 입력된 명령어를 해석하고 처리한 후 출력 결과를 생성합니다
- 구성은 3가지 요소 제어장치, 연산장치, 레지스터로 구성되어 있으며, 명령어 사이클(Fetch->Decode->Execute)의 흐름으로 작동합니다.


---
---
---

# 캐시 메모리에 대해 설명해주세요.
- 캐시 메모리는 CPU와 메인 메모리(RAM) 사이에 위치한 **고속 임시 기억장치**로,  CPU가 자주 사용하는 데이터나 명령어를 **미리 저장**해두는 역할.

- 속도 향상 이라는 장점을 얻지만, 용량이 적기도 하고 비용이 비쌈
- CPU에는 이러한 캐시 메모리가 2-3개 정도 사용 (L1,L2,L3)


## 계층 구조
- L1 : CPU 내부에 존재 (CPU 코어당 별도 존재, 가장 먼저 접근)
- L2 : CPU와 RAM 사이에 존재 (L1 미스 시 접근)
- L3 : 보통 메인보드에 존재한다고 함 (멀티코어 CPU에서 공유)

## 동작 흐름
- 1. CPU가 명령어/데이터를 요청
- 2. 먼저 L1 캐시 확인 → 없다면 → L2 확인 → 없다면 → L3 확인
- 3. 그래도 없으면 → RAM(메인 메모리) 접근 → 해당 데이터 캐시에 저장해두고 사용

> 👉 이 과정을 **캐시 히트(Cache Hit)/ 캐시 미스(Cache Miss)**, 

---

### ✨ 정리 포인트
- 캐시 메모리는 CPU와 메인 메모리(RAM) 사이에서 동작하는 고속 임시 기억 장치입니다. 
- CPU는 매우 빠르게 작동하지만, 메인 메모리의 속도는 상대적으로 느리기 때문에 데이터를 자주 메모리에서 가져오면 병목이 발생할 수 있습니다.
- L1, L2,L3로 구분되는 계층 구조를 갖고 있으며 CPU가 요청한 데이터가 캐시에 있을 경우 히트(Hit), 없을 경우 미스(Miss)발생하고, 결국 RAM에서 데이터를 가져와 캐시에 저장합니다.


---
# 📅 2025/05/19
# 실수 표현(고정소수점 & 부동소수점)에 대해 설명해주세요
- 컴퓨터는 기계어를 사용하여 모든 정보를 0과 1의 2진수로 처리한다
- 컴퓨터는 실수를 표현하기 위해 고정 소수점과 부동 소수점 방식을 사용한다

## 고정소수점(Fixed-point)
- 소수점의 위치가 고정되어 있음
- 정수처럼 표현하면서 소수점 위치를 약속해놓는 방식

<br>

```java
00011001 → 0001.1001 (이진수) → 1.5625 (10진수)
```

<br>

![alt text](image.png)
- 고정 소수점 표현 방식은 부호비트, 정수부, 소수부로 구성되어있다.
- 고정 소수점 방식은 표현하는 과정은 편리하지만, 정수부와 소수부의 자릿수 제한으로 표현 가능한 수의 범위 및 정밀도가 떨어지기 때문에 잘 사용되지 않는다.


## 부동소수점(Floating-point)
- 소수점의 위치가 떠다니는 구조
- IEEE 754는 전기 전자 기술자 협회(IEEE)에서 개발한 컴퓨터에서 부동소수점을 표현하는 가장 널리 쓰이는 표준으로 실수를 저장하는 데는 32bit 또는 64bit를 사용한다.
- IEEE 754의 부동 소수점 표현 방식은 부호비트, 지수부분(exponent)과 가수부분(fraction/mantissa)으로 구성되어있다.

![alt text](image-1.png)

- 부호비트 (Sign Bit)는 맨 앞 1bit로 0은 양수를, 1은 음수를 의미한다.
- 부동소수점은 실수를 정규화 하여 지수부와 가수부로 표현한다.

<br>

```java
1. 12.375 = 1100.011 (이진수)
2. 정규화: 1.100011 × 2^3
3. 부호: 1
4. 지수: 3 + 127 = 130 → 10000010
5. 가수: 10001100000000000000000

최종: 1 | 10000010 | 10001100000000000000000
```

- 부동소수점 표현 방식은 고정소수점에 비해 복잡하지만 표현 가능한 수의 범위와 정밀도가 크다는 장점이 있다. 현재 대부분의 컴퓨터는 부동소수점 표현 방식을 사용한다.
- 다만 표현하고자 하는 수가 1/2^n의 합으로 나타내지지 않으면 이진법에서 무한소수가 되고 비트는 한정되어있기 때문에 오차가 발생한다.


# 패리티 비트 & 해밍 코드란?
- 정보의 전달 과정에서 **오류**가 생기는 것을 검사하고 수정하기 위해 패리티 비트와 해밍 코드를 사용한다

## 패리티 비트(Parity Bit)
- 패리티 비트는 정보의 전달 과정에서 오류가 생겼는지를 **검사**하기 위해 추가된 비트
- 1Byte(8bit) 데이터에서 7bit 크기의 ASCII 코드를 제외한 나머지 1bit가 패리티(Parity) 비트이다.
- 패리티비트를 포함하여 1의 개수가 짝수나 홀수개가 되도록 하여 오류를 검출한다

## 종류
| 종류                  | 설명                       |
| ------------------- | ------------------------ |
| 짝수 패리티(Even Parity) | 1의 개수가 짝수가 되도록 패리티 비트 설정 |
| 홀수 패리티(Odd Parity)  | 1의 개수가 홀수가 되도록 패리티 비트 설정 |


## 예제
# 짝수 패리티
- 1의 개수를 짝수로 맞춘다.
- 1101001의 데이터는 1의 개수가 4개(짝수) 이므로, 짝수 패리티 비트는 0이 된다.
- 데이터: 1011001 → 1의 개수: 4 (짝수) → 패리티 비트: 0
- 전송: 10110010

# 홀수 패리티
데이터: 1011011 → 1의 개수: 5 (홀수) → 패리티 비트: 1
전송: 10110111

## 해밍 코드(Hamming Code)
- 데이터 전송 중 **1비트 오류를 자동으로 감지하고 고칠 수 있는 코드**


## 해밍 코드 생성
- 8bit 기준으로 2의 n승 번째 자리인 1, 2, 4번째 자리에 패리티 비트가, 그리고 나머지에 ASCII 코드가 들어간다.
 - 아래의 이미지 처럼, pn(2^n번째 패리티비트)은 n의 간격으로 n개의 bit를 확인하여 패리티비트를 결정한다.
p2는 2, 3, 6, 7번째 비트를 확인하여 패리티비트를 결정한다.

![alt text](image-2.png)


## 자릿수 배치 규칙
- 데이터 비트 + 패리티 비트
- r = 패리티 비트 수
- m = 데이터 비트 수
- 2^r ≥ m + r + 1

## 예제
- 예시 데이터: 1 0 1 1 (총 4비트)
| 위치 | 1  | 2  | 3  | 4  | 5  | 6  | 7  |
| -- | -- | -- | -- | -- | -- | -- | -- |
| 내용 | P1 | P2 | D1 | P4 | D2 | D3 | D4 |

## 패리티 비트 계산
각 패리티 비트는 특정 위치들을 XOR해서 계산해!
✔ P1 (위치 1) → 체크 위치: 1, 3, 5, 7
값: P1, 1(D1), 0(D2), 1(D4)

계산: 1 ⊕ 0 ⊕ 1 = 0 → P1 = 0

✔ P2 (위치 2) → 체크 위치: 2, 3, 6, 7
값: P2, 1(D1), 1(D3), 1(D4)

계산: 1 ⊕ 1 ⊕ 1 = 1 → P2 = 1

✔ P4 (위치 4) → 체크 위치: 4, 5, 6, 7
값: P4, 0(D2), 1(D3), 1(D4)

계산: 0 ⊕ 1 ⊕ 1 = 0 → P4 = 0

## 최종 해밍 코드 결과
| 위치 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
| -- | - | - | - | - | - | - | - |
| 비트 | 0 | 1 | 1 | 0 | 0 | 1 | 1 |


--- 
# ARM 프로세스에 대해 설명해주세요
- ARM(Advanced RISC Machine) 프로세서는 RISC(축소 명령어 집합 컴퓨터) 기반의 저전력·고효율 CPU 아키텍처를 말한다

## ARM 프로세스 등장 배경
컴퓨터 기술이 현대화됨에 따라 고성능, 소형화를 추구하게 됐고, 80년대 아콘 컴퓨터는 마이크로컴퓨터를 설계했지만 칩 설계로 인한 한계를 느끼고 있었다.
<br>
비슷한 시기, 캘리포니아 대학교 버클리 캠퍼스의 한 프로젝트에서 한 프로그래머가 대부분의 프로그램이 명령어 세트의 작은 하위 집합만 사용한다는 것을 발견했다.
<br>
복잡하고 구현하기 어려우며 거의 사용되지 않는 명령어를 제거하여 미리 정의된 명령어의 수를 줄이게 되면, 남은 간단한 명령어는 더 빠르게 실행될 수 있고 칩의 전력과 공간을 적게 차지하게 된다는 것이다.
<br>
이를 RISC(Reduced Instruction Set Computer)아키텍처라 한다.
<br>
아콘은 새 컴퓨터에 쓸 만한 기성품 CPU를 찾을 수 없었고, 버클리 RISC 프로젝트에서 영감을 받아 직접 RISC 기반 CPU 아키텍처를 개발하기로 하는데 이것이 ARM의 시작인 Acorn RISC Machine이다.
<br>

## 특징
| 특징           | 설명                                |
| ------------ | --------------------------------- |
|  저전력       | 전력 소모가 낮아서 배터리 수명이 중요한 모바일 기기에 적합 |
|  RISC 구조   | 간단한 명령어로 빠르고 효율적인 실행 가능           |
|  고성능 대비 효율 | 파이프라이닝, 병렬 처리 등으로 성능 ↑            |
|  라이선스 기반   | ARM Holdings는 설계만 하고 라이선스를 판매     |



# 📅 2025/06/03
# 컴퓨터 시스템에서의 인터럽트란?
- 컴퓨터 시스템에서 **인터럽트(interrupt)**는 프로세서(CPU)가 현재 실행하고 있는 프로그램의 정상적인 흐름을 일시적으로 중단하고, 특정 이벤트를 처리하기 위해 운영체제(OS)의 **인터럽트 핸들러(Interrupt Handler) 또는 인터럽트 서비스 루틴(Interrupt Service Routine, ISR)**으로 제어를 옮기는 메커니즘을 의미

## 인터럽트가 필요한 이유
- 인터럽트는 컴퓨터 시스템의 효율성과 반응성을 극대화하는 데 필수적인 요소입니다.

1. 입출력(I/O) 장치와의 효율적인 통신: CPU는 매우 빠르지만, 키보드, 마우스, 디스크 드라이브, 네트워크 카드와 같은 I/O 장치들은 CPU에 비해 훨씬 느립니다.
    - 폴링(Polling) 방식의 문제점: 인터럽트가 없다면 CPU는 I/O 장치가 작업이 끝났는지 계속해서 반복적으로 확인(폴링)해야 합니다. 이는 CPU 시간을 낭비하고 다른 유용한 작업을 수행할 수 없게 만듭니다.

    - 인터럽트 방식의 장점: I/O 장치가 작업이 완료되면 CPU에게 인터럽트를 걸어 알려줍니다. CPU는 그때까지 다른 작업을 수행하다가 인터럽트가 발생하면 잠시 하던 일을 멈추고 I/O 작업을 처리한 후 다시 원래대로 돌아옵니다. 이는 CPU의 활용도를 크게 높입니다.

2. 멀티태스킹/멀티프로그래밍 구현: 여러 프로그램이 동시에 실행되는 것처럼 보이는 멀티태스킹 환경에서 인터럽트는 필수적입니다. 운영체제는 타이머 인터럽트를 통해 각 프로그램에 CPU 시간을 할당하고, 할당된 시간이 끝나면 다음 프로그램으로 전환할 수 있습니다.

3. 예외 처리 (Error Handling): 프로그램 실행 중 발생하는 오류(예: 0으로 나누기, 잘못된 메모리 접근)나 시스템 오류를 감지하고 처리하는 데 사용됩니다.

4. 하드웨어 오작동 감지: 전원 공급 문제, 메모리 패리티 오류 등 하드웨어에서 발생하는 비정상적인 상황을 알리는 데 사용됩니다.

# 레지스터와 메모리의 차이점에 대해서 설명해주세요
# 레지스터(Register) 
- 레지스터는 **CPU 내부에 위치**하는 매우 작고 빠른 임시 저장 공간. CPU가 명령을 실행하고 데이터를 처리하는 데 필요한 모든 데이터와 중간 결과를 직접 저장합니다.

## 주요 특징
- 위치: CPU (중앙 처리 장치) 내부
- 속도: 컴퓨터 시스템에서 가장 빠릅니다. CPU와 거의 같은 속도로 동작합니다. CPU가 데이터를 직접 접근하여 연산에 사용하기 때문에 접근 시간이 거의 0에 가깝습니다.
- 용량: 매우 작습니다. 보통 몇 바이트에서 수십 바이트 정도의 데이터를 저장합니다. (CPU 아키텍처에 따라 달라짐)
- 비용: 속도가 매우 빠르고 CPU와 통합되어 있어 매우 비쌉니다.
- 역할:
    - 명령어 실행: 현재 실행 중인 명령어와 관련된 데이터를 저장합니다.
    - 임시 데이터 저장: 산술/논리 연산의 중간 결과나 자주 사용되는 데이터를 임시로 저장하여 CPU가 빠르게 접근할 수 있도록 합니다.
    - 특수 목적: 다음에 실행할 명령어의 주소를 저장하는 프로그램 카운터(PC), 현재 실행 중인 명령어를 저장하는 명령어 레지스터(IR), 스택의 최상단을 가리키는 스택 포인터(SP) 등 특수한 용도의 레지스터들도 있습니다.
- 휘발성: 전원이 꺼지면 데이터가 사라집니다.

# 메모리(Memory)
일반적으로 컴퓨터에서 '메모리'라고 부르는 것은 주로 **주기억장치(Main Memory)**인 **RAM (Random Access Memory)**을 의미합니다. 메모리는 CPU 외부에 위치하며, 현재 실행 중인 프로그램의 코드와 데이터를 저장하는 주된 공간입니다.

## 주요 특징

- 위치: CPU 외부 (메인보드에 장착된 RAM 모듈)
- 속도: 레지스터보다는 훨씬 느리지만, 하드 디스크(보조 기억장치)보다는 훨씬 빠릅니다. CPU는 메모리에 접근할 때 버스(Bus)를 통해 데이터를 주고받으므로 레지스터보다 시간이 더 걸립니다.
- 용량: 레지스터보다 훨씬 큽니다. 현재 일반적인 PC에는 수 기가바이트(GB)에서 수십 기가바이트의 RAM이 장착됩니다.
- 비용: 레지스터보다는 상대적으로 저렴하여 대용량을 제공할 수 있습니다.
- 역할:
    - 프로그램 코드 저장: 현재 실행 중이거나 실행될 프로그램의 명령어들이 저장됩니다.
    - 데이터 저장: 프로그램이 사용하는 데이터, 변수 등이 저장됩니다.
    - 운영체제 적재: 컴퓨터 부팅 시 운영체제가 하드 디스크에서 메모리로 로드되어 실행됩니다.
    - 가상 메모리 구현: 물리적 메모리보다 더 큰 주소 공간을 제공하여 효율적인 메모리 관리를 돕습니다.
- 휘발성: (RAM의 경우) 전원이 꺼지면 데이터가 사라집니다. (ROM은 비휘발성) 

## ✨ 정리 포인트
- 레지스터와 메모리는 컴퓨터 시스템의 성능을 최적화하기 위한 메모리 계층 구조의 일부입니다.

- 빠른 처리 속도를 위해 CPU에 가장 가까운 곳에 레지스터와 **캐시 메모리(Cache Memory)**를 둡니다. 이들은 빠르지만 비싸고 용량이 작습니다.
- 대용량 저장 공간을 위해 상대적으로 느리고 저렴한 **메모리(RAM)**를 사용합니다.
- 영구적인 저장을 위해 가장 느리지만 가장 저렴하고 대용량인 **보조 기억장치(하드 디스크, SSD)**를 사용합니다.
- CPU는 필요한 데이터를 가장 빠른 레지스터에서 먼저 찾고, 없으면 캐시, 그 다음 메모리, 마지막으로 보조 기억장치 순으로 찾아갑니다. 이 계층 구조 덕분에 컴퓨터는 비용 효율적으로 데이터를 관리하면서도 빠른 성능을 유지할 수 있습니다.

# 컴파일러와 인터프리터란?
- 컴퓨터는 0과 1로 이루어진 기계어(Machine Language)만 이해할 수 있습니다. 하지만 사람이 기계어로 직접 프로그래밍하는 것은 매우 어렵고 비효율적입니다. 그래서 우리는 C, Java, Python 등과 같은 **고급 프로그래밍 언어(High-level Language)**로 코드를 작성합니다.

## 컴파일러 (Compiler)
- 컴파일러는 프로그래밍 언어로 작성된 **전체 소스 코드(Source Code)**를 읽어서, 한 번에 통째로 컴퓨터가 이해할 수 있는 기계어 코드(Machine Code) 또는 중간 코드(예: Java의 바이트코드)로 변환하는 프로그램입니다. 이렇게 변환된 코드를 실행 파일(Executable File) 또는 목적 코드(Object Code)라고 합니다.

## 동작 방식
1. 전체 번역: 소스 코드 전체를 한 번에 스캔하여 분석하고 번역합니다.
2. 독립적인 실행 파일 생성: 번역 결과로 .exe(Windows), .app(macOS)와 같은 독립적인 실행 파일이 생성됩니다.
3. 실행: 이 실행 파일은 컴파일러 없이도 운영체제에 의해 직접 실행될 수 있습니다.

## 특징
- 컴파일 시간: 프로그램 실행 전에 전체 코드를 미리 번역해야 하므로, 컴파일 과정에 시간이 소요될 수 있습니다. 특히 프로젝트 규모가 크면 오래 걸립니다.
- 실행 속도: 한 번 컴파일되어 실행 파일이 만들어지면, 이후에는 번역 과정 없이 바로 실행되므로 실행 속도가 매우 빠릅니다.
- 디버깅: 컴파일 시 전체 코드에 대한 문법적 오류를 한꺼번에 발견할 수 있지만, 런타임 오류는 실행 중에만 알 수 있고 오류 발생 지점을 찾기 어려울 수 있습니다.
- 메모리 사용: 실행 파일을 생성하고 최적화하는 과정에서 상대적으로 많은 메모리를 사용할 수 있습니다.
- 이식성: 특정 운영체제나 CPU 아키텍처에 맞는 기계어로 컴파일되므로, 다른 환경에서 실행하려면 해당 환경에 맞게 다시 컴파일해야 할 수 있습니다 (낮은 이식성).
- 보안: 소스 코드가 직접 노출되지 않고 실행 파일만 배포되므로 소스 코드 보안에 유리합니다.
- 대표 언어: C, C++, Java (Java는 중간 바이트코드로 컴파일된 후 JVM에 의해 인터프리트되므로 하이브리드 성격을 띰)

## 인터프리터 (Interpreter)
- 인터프리터는 프로그래밍 언어로 작성된 소스 코드를 **한 줄씩 읽어서 즉시 실행**하는 프로그램. 별도의 실행 파일을 생성하지 않고, 소스 코드의 번역과 실행이 동시에 이루어진다.

## 동작 방식
1. 실시간 번역/실행: 소스 코드를 한 줄씩 읽어들여 해당 줄을 기계어로 번역하고 즉시 실행합니다.
2. 실행 파일 없음: 별도의 목적 파일이나 실행 파일을 생성하지 않습니다.
3. 매번 번역: 프로그램을 실행할 때마다 매번 한 줄씩 번역하고 실행합니다.

## 특징
- 컴파일 시간: 별도의 컴파일 과정이 없으므로, 코드를 수정하고 바로 실행해볼 수 있습니다. 시작 시간이 빠릅니다.
- 실행 속도: 프로그램을 실행할 때마다 매번 번역 과정을 거치므로, 컴파일 방식에 비해 실행 속도가 느립니다.
- 디버깅: 오류가 발생한 줄에서 실행이 멈추기 때문에 오류 발생 지점을 찾고 디버깅하기가 상대적으로 쉽습니다.
- 메모리 사용: 실행 파일을 생성하지 않으므로 컴파일러보다 메모리 사용 효율이 좋을 수 있습니다.
- 이식성: 특정 운영체제에 종속적인 기계어를 생성하지 않으므로, 인터프리터만 설치되어 있다면 어떤 환경에서든 소스 코드를 그대로 실행할 수 있습니다 (높은 이식성).
- 보안: 소스 코드가 직접 노출되므로 보안에 취약할 수 있습니다.
- 대표 언어: Python, JavaScript, Ruby, PHP