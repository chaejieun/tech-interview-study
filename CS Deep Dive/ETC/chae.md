# 📅 2025/05/08
# 스크립트 언어와 컴파일 언어를 나열하고 차이점을 설명해주세요

## 스크립트 언어 
- 소스 코드를 컴파일하지 않고 **인터프리터(프로그래밍 언어의 소스 코드를 바로 실행하는 컴퓨터 프로그램)로** 소스 코드를 한 줄 한 줄 읽어 바로 실행하는 방식으로 동작하는 언어
- Javascript, JSP, Python, Ruby

## 스크립트 언어 특징
- 컴파일 언어에 비해 단순하고 쉬운 문법 구조
- 컴파일러 없이 명령어를 한 줄씩 읽으면서 실행. 번역 속도는 빠르지만 프로그램 실행 시 매번 같은 코드를 번역해야 한다. 실행속도는 느리다.
- CPU의 사용시간의 낭비가 크므로 산술연산 혹은 복잡한 구조의 프로그램에서는 비효율적
- 컴파일 과정이 없기 때문에 프로그램을 실행시켜야 오류를 알 수 있음
- 컴파일 과정이 없기 때문에 소스 코드가 그대로 실행 파일이 되어 메모리에 적재된다.

## 컴파일 언어
- 소스코드를 컴파일하여 목적코드로 옮기고, 목적코드(기계어)를 읽어 실행시키는 방식으로 동작하는 언어
- 대표적으로 C++, Visual C++, Object C, Java, C

## 컴파일 언어 특징
- 문법적 제약이 많아 스크립트 언어에 비해 사용이 어렵다
- 컴파일을 하기 때문에 규모가 큰 프로그램일 경우 컴파일 소요 시간이 오래 걸린다
- 한번 컴파일을 하면, 이후에는 기계어를 읽어들이기 때문에 실행 속도가 빠르다
- 컴파일러가 소스코드를 기계어로 변환시켜준다. 그 이후 기계어가 메모리에 적재

## ✨ 정리 포인트
- 주의: Java는 중간 단계인 바이트 코드로 컴파일되고, JVM에서 실행되므로 '순수한 컴파일 언어'보다는 **컴파일 + 인터프리터 혼합 언어**로 분류되는 경우도 있다

<br>

# 코드리뷰 중 갈등이 있을 경우, 이를 어떻게 해결할 것인가요?
- 코드 리뷰 중, 한 팀원이 작성한 코드에서 중복된 로직이 반복되고 있다는 것을 발견했습니다. 제가 이전에 만든 함수 구조를 확장해서 사용할 수 있는 부분이 있어서, 재사용 가능한 형태로 리팩토링할 수 있다는 제안을 드렸습니다. 처음에는 팀원이 다소 당황해했지만, 해당 방식이 코드의 일관성과 유지보수 측면에서 더 효율적이라는 점을 설명드리니 긍정적으로 수용해주셨고, 실제로 개선된 코드를 함께 적용할 수 있었습니다. 이후 그 팀원도 유사한 리뷰 상황에서 저에게 피드백을 주었던 적이 있어, 리뷰가 단순한 평가가 아닌 상호 성장을 위한 과정이라는 걸 다시 느꼈습니다. 저는 이런 경험을 통해, 프로젝트의 품질 향상과 협업을 위해 리뷰에서 적극적으로 의견을 공유하고, 소통하는 것이 중요하다고 생각하게 되었습니다.

# 어떤 기술이나 방법론이 좋아보일 때, 이를 어떻게 설득할 것인가요
- 기존 프로젝트에서는 복잡한 조건 분기 로직으로 인해 코드 가독성이 떨어지고 유지보수도 어려운 상황이었습니다. 이를 개선하기 위해 전략 패턴을 제안드렸습니다. 해당 패턴이 적용된 예시 코드와 구조도를 함께 공유하며, 테스트를 통해 코드 변경 전후의 복잡도를 비교했습니다. 또한, 적용 시 어떤 부분이 더 유연하게 확장될 수 있는지, 새로운 정책이 추가될 때 어떤 이점이 있는지를 팀원들과 문서로 정리해 논의했습니다. 다행히 팀원들도 구조적인 장점에 공감해 주셔서 실제로 해당 방식을 적용했고, 이후 비슷한 유형의 문제를 해결하는 데에도 일관된 접근이 가능해졌습니다. 저는 이 경험을 통해 좋은 기술도 결국 ‘이해와 공감’으로 설득되어야 한다는 걸 배웠습니다.


# 📅 2025/05/23
# 일정이 예상보다 지연될 것 같습니다. 어떻게 해결하실 것인가요?
- 일단, 현재까지 진행 된 작업을 확인하고 남은 작업을 명확히 파악합니다.
- 예상보다 복잡한 로직이나 외부 API 연동 이슈로 일정이 밀릴 경우, 빠르게 팀장 혹은 PM에게 현재 상황을 공유하고 어느 정도의 예상 일정이 소요될 지 파악할 것입니다.
- 작업 업무 우선 순위를 세분화하고, 그 다음 어떻게 처리해야할 지 함께 공유하여 해결할 수 있도록 할 것입니다.


# 팀원과의 갈등이 있었나요? 있었다면 어떻게 대처했나요?
- 프론트엔드 개발자와의 협업 중, 제 일정에 맞춰 API 작업을 진행하긴 했지만, 프론트엔드 작업자분은 API 명세를 최대한 빠르게 확인하길 원하셨습니다.
서로의 작업 효율을 높이기 위해, API 명세를 엑셀로 구조화해 실시간으로 공유하며 동기화했고, Postman을 활용해 실제 요청 예시와 파라미터 구조도 함께 전달했습니다.
이러한 방식으로 커뮤니케이션하니,프론트 개발자분은 백엔드 작업이 완료되기 전에도
Mock 데이터를 활용해 화면을 먼저 개발할 수 있었고, 결과적으로 전체 일정이 지연 없이 원활하게 마무리될 수 있었습니다.

# 비개발 직군(기획자, 디자이너, 사업팀 등)과 소통할 때 기술적인 내용을 어떻게 설명하나요?
- 최대한 화면과 기능 흐름 중심으로 소통하려고 노력합니다. 기술적인 제약이나 예상되는 이슈가 있을 경우, 비개발자도 쉽게 이해할 수 있도록 유사한 예시를 들거나
간단한 시각 자료를 활용해 설명합니다. 이런 방식 덕분에 기획자나 디자이너분들과 소통이 원활했고, 서로의 입장을 이해하면서 협업 속도도 빨라졌던 경험이 많습니다.

# 📅 2025/06/09
# GitHub 및 Jira를 활용한 협업 경험을 공유해주세요.
- github : 코드 버전 관리, `main` 브랜치는 항상 배포 가능한 안정적인 코드를 유지하고, `develop` 브랜치는 현재 개발 중인 기능들을 통합하는 역할 사용. 각 기능 개발은 `feature/{기능명}` 브랜치에서 진행.
- jira : 애자일 방법론 적용. 스크럼 방식을 적용하여 스프린트 단위로 개발을 진행. jira 백로그에 사용자 스토리와 기술 태스크를 등록하고, 스프린트 계획 회의를 통해 각 스프린트에 포함될 작업을 결정하여 사용.

# 팀 내에서 코드 리뷰를 진행하는 방식과 주요 고려사항은 무엇인가요?
1. Pull Request 생성 : 개발자가 기능 개발을 완료하고 `develop` 브랜치로 병합하기 위해 Pull Request를 생성한다. 이떄 PR 설명에 어떤 기능인지, 변경사항, Jira 이슈 번호를 상세히 작성
2. 리뷰어 지정 : 대체로 팀장님이 진행
3. 리뷰 및 댓글 : PR의 변경사항 검토 및 코드 리뷰 피드백 
4. 피드백 반영 및 수정 : 수정 사항은 PR에 자동 업데이트하며 작업
5. 승인(Approve) : 모든 피드백이 반영되고 코드가 기준을 충족한다고 판단되면, 리뷰어는 PR을 승인한다.
6. 병합(Merge) : 필요한 승인을 모두 받으면 PR을 `develop` 브랜치로 병합하고, 해당 기능 브랜치는 삭제한다. 

# 코드 품질과 개발 속도 사이에서 균형을 맞추기 위한 본인의 접근 방식은 무엇인가요?
1. 초기 단계에서 코드 품질 기준 합의 및 자동화
- 코딩 컨벤션, 코드 리뷰 가이드라인, 정적 분석 도구(SonarQube, Checkstyle)의 규칙을 명확히 정의하고 합의한다.
2. CI/CD 파이프라인에 이러한 도구를 통합하여 코드 품질 검사를 한다.
3. 점진적 개선 및 리팩토링을 통해 단계적으로 개선한다.
4. 팀원 간의 지속적인 소통 및 피드백을 중요시 한다. 

# 📅 2025/06/24
# 좋은 소스란, 좋은 코드, Clean Code란 어떤것인가요?
- 좋은 소스 코드, 즉 클린 코드는 단순히 작동하는 코드를 넘어, 개발자와 팀에 지속적으로 가치를 제공하는 코드 입니다.
1. 읽기 쉬운 코드
2. 이해하기 쉬운 코드
3. 변경하기 쉬운 코드
4. 안정적인 코드

클린 코드는 단순히 아름다운 코드를 넘어, 유지보수, 확장, 그리고 팀 협업의 효율성을 극대화하는 실용적인 목표이다. 처음에는 시간이 더 걸리는 것처럼 보이지만, 장기적으로는 개발 비용을 줄이고 소프트웨어의 수명을 늘리는 데 결정적인 역할을 합니다. 

# 최근 1년간 새롭게 학습한 기술이나 도구는 무엇이며, 이를 프로젝트에 어떻게 적용했나요?
- **Redis와 비관적 락(Pessimistic Locking)** 입니다.
- Redis는 캐싱 전략을 수립할 때 선택한 도구로, 공지사항API의 조회 성능 개선을 위해 적용했습니다. 조회 수가 많은 공지사항 데이터를 Redis에 캐싱하여 DB 부하를 줄이고 응답 속도를 개선하는 데 기여했습니다. TTL 설정 및 Cached Aside 패턴을 활용하여 안정적으로 운영할 수 있도록 했습니다.
- 또한, 동시성 문제가 발생할 수 있는 시나리에오 비관적 락을 적용하여 데이터 정합성을 보장했습니다. 예를 들어, 상품 수량을 업데이트 하는 API에서 동시에 여러 사용자가 접근할 경우 `@Lock(LockModeType.PESSIMISTIC_WRITE)`를 사용하여 문제를 해결했습니다. 



# 기술 부채를 관리하는 본인만의 방법이 있나요?
- 저는 기술 부채를 단순히 ‘나중에 고쳐야 할 코드’가 아닌, 지속적인 관리와 소통이 필요한 이슈로 인식하고 있습니다.

제가 사용하는 기술 부채 관리 방법은 다음과 같습니다:

- 부채 식별과 명시화
코드 작성 시, 나중에 개선이 필요하거나 구조적으로 불안정한 부분이 있으면 `TODO`, `FIXME` 주석과 함께 `GitHub Issue`로 등록합니다. 이슈 템플릿에는 “원인”, “현 상황”, “개선 방향”, “긴급도”를 작성해 둡니다.

- 우선순위 분류
긴급도에 따라 단기 해결 가능한 기술 부채와 아키텍처 수준의 장기적 부채로 나누고, 스프린트 회의 때 팀과 함께 우선순위를 정합니다.

- 리팩토링 및 주기적 점검
큰 기능 개발이 끝난 후 버퍼 기간에 리팩토링 전용 브랜치를 운영하거나, 병합 전에 SonarQube, IntelliJ Code Inspection 등 정적 분석 도구를 활용하여 잠재적인 부채를 점검합니다.

예를 들어, 한 프로젝트에서는 API 응답을 DTO로 감싸지 않고 바로 Entity를 반환했던 적이 있습니다. 빠른 개발을 위해 처음엔 그렇게 구현했지만, 유지보수가 어려워지고 보안 이슈도 생겨서, 따로 Issue를 생성하고 점진적으로 DTO 구조로 리팩토링하며 해결했습니다.


# 📅 2025/08/05
# 자신이 개발한 기능 중 가장 도전적이었던 것은 무엇이며, 어떻게 해결했나요?
제가 개발한 기능 중 가장 도전적이었던 경험은, 블록체인 민팅 기능을 구현했던 프로젝트였습니다.
이전에 한 번도 블록체인이나 스마트 컨트랙트를 다뤄본 적이 없어서, 처음부터 학습하고 구현까지 해내야 했던 프로젝트였어요.

우선 Solidity 언어로 컨트랙트를 작성하는 방법부터 배웠고, 실제로 돌아가는 코드를 만들기 위해 굉장히 많은 자료를 찾아봤습니다.
공식 문서, 블로그, GitHub 오픈소스 등을 참고하면서 기초부터 쌓아 나갔고, 실습은 Hardhat 환경에서 진행했어요.

특히 테스트넷에서 여러 번 배포해보고 직접 민팅을 시도해보는 과정을 반복하면서 많은 문제를 경험했고, 그때마다 왜 그런 오류가 났는지 디버깅하고 하나씩 해결해 나갔습니다.
예를 들어 가스 비용 문제라든가, 컨트랙트 권한 설정 오류 등 다양한 이슈를 겪었고, 그 과정에서 실전 감각도 많이 익힐 수 있었어요.

결국에는 안정적으로 민팅이 가능한 스마트 컨트랙트를 구현하고 배포하는 데 성공했고, 이 경험을 통해 낯선 기술을 빠르게 흡수하고 적용하는 데 자신감을 갖게 되었습니다.

# 본인이 생각하는 이상적인 개발 문화는 무엇이며, 이를 조성하기 위해 어떤 노력을 할 수 있을까요?
제가 생각하는 이상적인 개발 문화는, 혼자만의 개발이 아닌 팀이 함께 방향을 맞춰가며 완성해 나가는 협업 중심의 문화입니다.
개발은 결국 하나의 서비스를 완성하기 위한 과정이기 때문에, 개인의 코드 퀄리티도 중요하지만 서로의 아이디어를 조율하고, 역할을 나누고, 목표를 함께 공유하는 과정이 필수적이라고 생각합니다.

실제로 의견이 달라 충돌이 생기거나, 방향성이 어긋나는 경우도 있을 수 있지만, 그런 상황에서 서로를 존중하며 커뮤니케이션을 지속하는 태도가 건강한 개발 문화를 만든다고 믿습니다.

저는 이런 문화를 조성하기 위해 의견이 다른 경우에도 감정이 아닌 논리 중심으로 대화하려고 노력하고, 문서화나 코드 리뷰 등을 통해 열린 소통을 하고자 합니다.또한 팀원 간의 작은 성과도 서로 칭찬하고 피드백을 주는 분위기를 만들기 위해 노력합니다.


# 프로젝트의 성공과 실패를 어떻게 정의하나요? 성공적/실패했다고 생각하는 프로젝트 경험을 공유해주세요.
저는 프로젝트의 성공과 실패를 단순히 결과만으로 판단하지 않고, 목표한 가치를 사용자에게 전달했는지, 그리고 그 과정에서 팀이 유의미한 성장을 했는지에 따라 정의합니다.

실제로 제가 참여한 프로젝트 중 하나는, 약 1년 간 개발에 참여했음에도 서비스의 기획 미흡과 완성도 부족으로 인해 결국 출시가 무산되며 실패한 경험이 있습니다. 당시에는 개발에만 집중하다 보니, 비즈니스 모델이나 사용자 니즈를 충분히 고려하지 못한 채 기능 구현에만 몰두했고, 그 결과 프로젝트의 방향성이 흐려졌습니다. 

이 경험을 통해 단순히 기능을 만드는 것이 전부가 아니라, 팀원 간의 긴밀한 소통과 기획 초기 단계부터의 참여, 그리고 고객 중심의 사고 방식이 얼마나 중요한지를 절실히 느꼈습니다.

실패한 프로젝트였지만, 그 과정을 통해 저는 서비스 기획 단계부터 주도적으로 의견을 제시하고 개발 중간에도 팀원들과 지속적으로 피드백을 주고받는 문화를 만들기 위해 더 많이 소통하려 노력하게 되었습니다. 결국 이 경험은 저에게 “기술은 수단일 뿐, 본질은 사용자에게 가치를 주는 것”이라는 관점을 가지게 해준 소중한 계기였습니다.