1. Array와 List의 차이에 대해 설명해주세요.
   Array는 고정 크기의 연속된 메모리 공간에 데이터를 저장합니다. Array는 인덱스를 통해 원소에 빠르게 접근할 수 있어 조회 속도가 빠릅니다. 단 크기를 미리 지정해야하고, 중간에 요소를 삽입하거나 삭제하는 작업이 느립니다.
   List는 크기를 동적으로 조절하여 저장할 수 있습니다. 자동으로 크기를 늘리거나 줄일 수 있어 유연합니다.

2. Linked List란?
   Linked List는 데이터를 연결 구조로 저장하는 선형 자료구조입니다. Linked List는 각 데이터 노드가 다음 노드의 주소를 함께 저장해서 메모리상 연속되지 않아도 데이터를 순서대로 연결할 수 있습니다.
   Linked List의 장점은 삽입과 삭제가 빠르다는 점입니다. 중간이나 앞부분의 데이터를 삽입 삭제할 때, 포인터만 바꿔주면 되어 효율적입니다. 단점은 인덱스로 직접 접근이 불가능하여 검색 속도가 느린 편입니다.

3. List와 Set의 차이에 대해 설명해주세요
   List와 Set은 모두 여러 데이터를 저장할 수 있는 컬렉션이지만, 중복 여부와 순서 유지 여부에서 차이가 있습니다.
   List는 **중복된 값을 허용하고 저장한 순서를 그대로 유지합니다.**
   인덱스를 기반으로 한 순차적 접근이 가능하며 특정 위치에 삽입 삭제를 할 수 있습니다. List의 예시로는 ArrayList, LinkedList 등이 있습니다.
   Set은 **중복된 값을 허용하지 않으며, 요소 간의 순서를 보장하지 않고 조건에 따라 정렬**됩니다.
   Set의 예시로는 중복만 제거하는 HashSet, 정렬된 형태로 저장되는 TreeSet, 삽입 순서를 유지하는 LinkedHashSet 등이 있습니다.

# 📅 2025/05/20

4. 스택(Stack) & 큐(Queue) & 덱(Deque)에 대해서 설명해주세요.
   **스택**은 데이터를 일렬로 쌓아 올린 자료구조입니다. 후입선출(LIFO) 방식으로 동작합니다. 주요 연산으로는 push, pop, peek이 있습니다. push는 데이터를 스택의 맨 위에 추가하는 연산입니다. pop은 스택의 맨 위에 있는 데이터를 제거 및 반환하는 연산입니다. peek은 맨 위의 데이터를 제거하지 않고 확인합니다.
   **큐**는 데이터를 한 줄로 세운 형태의 자료구조로, 선입선출(FIFO) 방식으로 동작합니다. 주요 연산으로는 enqueue, dequeue, peek이 있습니다. enqueue는 데이터를 큐의 뒤쪽에 추가합니다. dequeue는 큐의 앞쪽에 있는 데이터를 제거 및 반환합니다. peek은 앞쪽 데이터를 제거하지 않고 확인합니다.
   **덱**은 큐의 일종으로 양쪽 모두에서 데이터의 삽입과 삭제가 가능한 자료구조입니다. addFirst/Last로 데이터를 앞 또는 뒤에 추가를 할 수 있고 removeFirst/Last로 데이터를 앞 또는 뒤에 제거할 수 있습니다. peekFirst/Last로 데이터의 앞 또는 뒤에서 확인할 수 있습니다.

5. Heap, Priority Queue에 대해서 설명해주세요
   **Heap**은 완전 이진트리 형태로 구현되는 트리 기반의 자료구조입니다. 노드 간의 우선순위에 따라 부모 노드가 자식 노드보다 큰 최대 힙을 가지거나 부모 노드가 자식보다 작은 최소 힙의 특성을 가집니다.
   **우선순위 큐**는 데이터에 우선순위를 부여해서 우선순위가 가장 높은 데이터가 먼저 나오는 큐입니다. 우선순위 큐는 일반적인 큐와 달리, 우선순위가 높은 데이터가 먼저 나오며 삽입 시 우선순위를 고려하여 저장합니다. 구현 방법으로는 주로 Heap이 사용됩니다. Heap외에도 배열, 연결리스트로도 구현이 가능하지만 비효율적이기 때문에 주로 Heap을 사용합니다. 주요 연산으로는 데이터를 우선순위와 함께 삽입하는 insert, 우선순위가 가장 높은 데이터를 제거 및 반환하는 remove, 우선순위가 가장 높은 데이터를 확인하는 peek이 있습니다.

6. Tree, Binary Tree, BST, AVL Tree에 대해서 설명해주세요
   **트리(Tree)**는 계층적 구조를 가진 비선형 자료구조입니다. 노드와 간선으로 구성되어 있으며 루트 노드를 기준으로 부모-자식 관계를 가집니다. 트리 구조의 특징은 순환이 없는 그래프이고 한 노드는 여러 개의 자식을 가질 수 있습니다. 또한 계층적 데이터 표현에 사용이 됩니다.
   **이진트리(Binary Tree)**는 각 노드가 최대 두 개의 자식 노드를 가지는 트리 구조입니다. 특징은 자식 노드의 개수가 0, 1, 2개 일 수 있으며 다양한 파생구조의 기본구조라는 것입니다. 파생구조의 예로는 이직 탐색 트리, 완전 이진 트리 등이 있습니다.
   **이진 탐색 트리(BST)**는 이진 트리의 한 종류로, 왼쪽 서브트리에는 현재 노드보다 작은 값, 오른쪽 서브트리에는 현재 노드보다 큰 값이 위치하도록 정렬된 구조입니다. 특징은 탐색, 삽입, 삭제 연산의 평균 시간 복잡도가 O(log n)인 것과 중복된 값은 일반적으로 허용하지 않는 것, 트리의 균현이 깨지면 성능이 O(n)까지 떨어질 수 있다는 것입니다.
   **아벨트리(AVL Tree)**는 이진 탐색 트리의 한 종류로 항상 균형을 유지하는 트리입니다. 이에 균형 이진 탐색 트리로 불리며, 모든 노드의 왼쪽/오른쪽 서브트리의 높이 차이가 1이하가 되도록 자동으로 조정됩니다. 특징은 각 노드마다 균형 인수를 기록하며 삽입 또는 삭제 시 트리의 불균형이 발생하게 되면 회전을 통해 균형을 유지합니다. 항상 O(log n)의 탐색, 삽입, 삭제 시간 복잡도를 보장합니다.

## 📅 2025/06/04

7. BST의 최악의 경우의 예와 시간복잡도에 대해서 설명해주세요
   BST란 왼쪽 자식은 루트보다 작은 값, 오른쪽 자식은 루트보다 큰 값을 가지는 이진 트리 구조입니다. 기본적인 삽입, 삭제, 탐색 연산은 O(log n)의 시간 복잡도를 기대할 수 있습니다.

   **최악의 경우**
   데이터가 **정렬된 순서(오른참순 또는 내림차순)**로 삽입될 경우 트리가 한쪽으로 치우쳐 **선형 구조**가 됩니다.
   이 경우 BST는 사실상 **Linked List와 동일**하게 되어 효율이 급격히 저하됩니다.

   **시간 복잡도**
   | 연산 | 평균 시간복잡도 | 최악 시간복잡도 (편향 트리) |
   | -- | -------- | ---------------- |
   | 삽입 | O(log n) | O(n) |
   | 탐색 | O(log n) | O(n) |
   | 삭제 | O(log n) | O(n) |

8. 해시(Hash)란?
   해시는 임의의 데이터를 고정된 크기의 값으로 매핑하는 기술로, 주로 빠른 데이터 검색과 저장을 위해 사용됩니다.
   **구성 요소**
   해시 함수: 입력 데이터를 해시값으로 변환
   해시 테이블: 해시값을 인덱스로 사용하는 데이터 저장 구조

   **특징**

   - 평균적으로 탐색, 삽입, 삭제 모두 O(1) 성능
   - 충돌(해시값 중복)이 발생할 수 있고 이를 해결하기 위해 체이닝, 오픈 어드레싱을 사용해야 함

   **활용 예시**

   - HashMap, HashSet

9. B-Tree & B+Tree 란?
   _B-Tree_
   다수의 자식을 갖는 균형 이직 탐색 트리이다. 데이터베이스, 파일 시스템 등에서 디스크 I/O를 최소화하기 위해 설계된다. 데이터베이스, 파일 시스템 등에서 디스크 I/O를 최소화하기 위해 설계된다.

   _B+Tree_
   B-Tree의 확장 구조이다. 데이터는 오직 리프 노드에만 저장하고, 내부 노드는 인덱싱용 키만 저장한다.

   **비교**
   | 항목 | B-Tree | B+Tree |
   | --------- | --------------- | --------------------- |
   | 데이터 저장 위치 | 모든 노드에 저장 | 리프 노드에만 저장 |
   | 인덱스 노드 | 데이터와 키 모두 저장 | 키만 저장 |
   | 범위 검색 | 비효율적 (트리 탐색 반복) | 효율적 (리프 노드 순차 접근 가능) |
   | 활용 예시 | 파일 시스템 | 관계형 데이터베이스 인덱스(RDBMS) |
