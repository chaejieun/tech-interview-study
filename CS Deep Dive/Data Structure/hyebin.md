### 1. Array와 List의 차이에 대해 설명해주세요
- Array는 고정된 크기를 가진 연속된 메모리 공간
    - 동일한 타입의 요소를 저장
    - 인덱스를 통한 빠른 접근(O(1))이 가능 
    - 크기 변경이 불가능
- List는 동적 배열로 구현되어 요소 추가 시 자동으로 크기가 조정 
    - 다양한 타입을 저장  
    - 요소 추가/삭제에 유연하지만 내부적으로 배열을 재할당하는 과정에서 오버헤드가 발생

### 2. Linked List란?
- 각 노드가 데이터와 다음 노드를 가리키는 포인터로 구성된 자료구조 
- 메모리에 연속적으로 저장되지 않고 포인터를 통해 연결되어 있어 중간 요소의 삽입/삭제 가능 
- 특정 요소에 접근하려면 처음부터 순차적으로 탐색
- 각 노드마다 포인터를 저장하기 위한 추가 메모리가 필요

### 3. List와 Set의 차이에 대해 설명해주세요
- List
    - 순서가 있고 중복 요소를 허용하는 컬렉션으로 인덱스를 통한 요소 접근이 가능
    - ArrayList나 LinkedList로 구현
- Set 
    - 순서가 없고 중복 요소를 허용하지 않는 컬렉션으로 요소의 존재 여부를 빠르게 확인 가능 
    - 고유성이 중요한 데이터 관리에 적합
    - HashSet, TreeSet 등으로 구현

### 4. 스택(Stack) & 큐(Queue) & 덱(Deque)에 대해서 설명해주세요
- 스택 (Stack): 한쪽 끝에서만 데이터를 넣고 뺄 수 있는 후입선출(LIFO, Last In First Out) 구조
    - 활용 예시
        - 함수 호출 스택
        - 괄호 유효성 검사
        - 웹 브라우저 뒤로가기 기능
- 큐 (Queue): 한쪽에서 넣고, 반대쪽에서 꺼내는 선입선출(FIFO, First In First Out) 구조
    - 활용 예시
        - 작업 스케줄링
        - BFS 탐색
        - 프린터 대기열
- 덱 (Deque, Double-Ended Queue): 양쪽 끝에서 데이터를 삽입/삭제할 수 있는 자료구조
    - 활용 예시
        - 슬라이딩 윈도우 최대/최소 문제
        - 회전 큐 구현


### 5. Heap, Priority Queue에 대해서 설명해주세요
- 힙 (Heap): 완전 이진 트리 형태의 자료구조로, 부모 노드가 자식 노드보다 크거나(최대 힙), 작거나(최소 힙) 한 속성을 가짐
    - 종류
        - 최소 힙: 부모 노드 ≤ 자식 노드
        - 최대 힙: 부모 노드 ≥ 자식 노드
    - 시간 복잡도
        - 삽입, 삭제: O(log n)
        - 최댓값/최솟값 확인: O(1)

- 우선순위 큐 (Priority Queue): 데이터에 우선순위를 부여해, 높은 우선순위를 가진 데이터가 먼저 나오는 큐
    - 대부분 힙(Heap) 으로 구현

6. Tree, Binary Tree, BST, AVL Tree에 대해서 설명해주세요
- 트리 (Tree): 계층적 구조를 가지는 비선형 자료구조. 하나의 루트 노드에서 시작해 여러 노드로 분기됨
    - 특징
        - 루트(root), 부모/자식 노드, 리프 노드 등으로 구성
        - 사이클이 없는 방향성 있는 그래프의 일종

- 이진 트리 (Binary Tree): 각 노드가 최대 2개의 자식 노드를 가지는 트리
    - 종류
        - 포화 이진 트리, 완전 이진 트리, 균형 이진 트리 등

- 이진 탐색 트리 (BST, Binary Search Tree): 왼쪽 자식은 현재 노드보다 작고, 오른쪽 자식은 현재 노드보다 큰 값만 저장하는 정렬된 이진 트리
    - 특징
        - 탐색, 삽입, 삭제 평균 시간 복잡도: O(log n) (단, 트리 균형 유지 시)
        - 최악의 경우(편향 트리): O(n)

- AVL 트리: 자기 균형 이진 탐색 트리. 삽입 또는 삭제 이후 트리의 균형을 맞추기 위해 회전을 수행
    - 균형 조건: 모든 노드에서 왼쪽과 오른쪽 서브트리의 높이 차이가 최대 1 이하
    - 회전 종류: LL, RR, LR, RL 회전
    - 시간 복잡도
        - 삽입, 삭제, 탐색: 항상 O(log n) 보장

## 📅 2025/06/04
### 7. BST의 최악의 경우의 예와 시간복잡도에 대해서 설명해주세요
-  Binary Search Tree: 이진 트리(Binary Tree)의 일종
    - 각 노드는 최대 두 개의 자식을 가짐 (left, right)
    - 왼쪽 자식 노드에는 현재 노드보다 작은 값
    - 오른쪽 자식 노드에는 현재 노드보다 큰 값
- 삽입 (Insert)
    - 루트부터 시작해서, 값이 작으면 왼쪽, 크면 오른쪽으로 이동하여 빈 자리에 추가
- 탐색 (Search)
    - 루트부터 비교하며 왼쪽 또는 오른쪽으로 이동
    - 평균 O(log n), 최악 O(n)
- 삭제 (Delete)
    - 자식이 없음 → 바로 삭제
    - 자식이 하나 → 자식 노드로 교체
    - 자식이 둘 → 오른쪽 서브트리에서 최소값 혹은 왼쪽 서브트리에서 최대값으로 대체
- 활용
    - DB 인덱스 구조의 기초 (단, 실제 DB에서는 B-Tree, B+Tree 사용)
    - 트리 기반 탐색 구조
    - 오름차순 정렬된 출력 (중위 순회)
- 최악의 경우: 정렬된 입력 → O(n) (편향 트리)
- 평균: O(log n)

### 8. 해시(Hash)란?
- 키(key)를 해시 함수(hash function)를 통해 특정 위치(인덱스)로 매핑시켜 빠르게 데이터를 찾는 방법
- 키를 해시함수로 인덱스로 변환 → 빠른 검색 (O(1) 기대)
- 구조
    - 해시 테이블(Hash Table): 해시된 인덱스를 기준으로 데이터를 저장하는 배열 기반 자료구조
    - 해시 함수(Hash Function): 키를 고정 크기의 인덱스로 변환
    - 충돌(Collision): 서로 다른 키가 같은 인덱스를 가질 경우
- 충돌 해결 방식
    - 체이닝 (Chaining)
        → 충돌 시 동일 인덱스에 연결 리스트로 데이터 저장
    - 오픈 어드레싱 (Open Addressing)
        → 빈 자리를 찾아 저장 (선형 탐사, 이차 탐사, 이중 해싱 등)

### 9. B-Tree & B+Tree 란?
- B-Tree: 다중 분기(multi-way branching)를 허용하는 균형 잡힌 탐색 트리
    - 리프/내부 노드 모두 데이터 저장
    - DB나 파일 시스템에서 사용되는 트리 기반 인덱싱 구조
    - 특징
        - 모든 리프 노드는 같은 깊이
        - 내부 노드도 데이터 보유
        - 한 노드에 여러 키와 자식 노드 저장 → 디스크 접근 최소화
        - 노드 내 키는 정렬된 상태 유지
    - 활용 
        - 데이터베이스 인덱스 (MySQL, PostgreSQL 등)
        - 파일 시스템 (NTFS 등)
- B+Tree: B-Tree를 확장한 구조로, 모든 실제 데이터는 리프 노드에만 저장되고, 내부 노드는 경로 정보만 저장하는 트리
    - 데이터는 리프에만, 순차 접근에 유리
    - 활용
        - 대부분의 관계형 데이터베이스에서 인덱스로 사용 (MySQL의 InnoDB도 B+Tree 기반)
        - 파일 시스템의 인덱스 구조