1. 시간복잡도와 공간복잡도란?
   시간 복잡도와 공간 복잡도는 알고리즘의 효율성을 평가하는 기준입니다.
   시간 복잡도는 입력 크기 n에 따라 수행해야 하는 연산의 수입니다. 주로 O(1), O(n), O(n²), O(log n)과 같은 Big-O 표기법을 사용해서 표현합니다.
   공간 복잡도는 입력 크기 n에 따라 알고리즘이 동작하는 동안 추가로 필요한 메모리 양을 나타냅니다. 시간 복잡도처럼 Big-O로 표현합니다.
   시간 복잡도는 **얼마나 빨리 동작하는가** 공간 복잡도는 **얼마나 많은 메모리를 쓰는가** 평가하는 기준입니다.

2. 피보나치 수열을 코드로 구현하는 방법에 대해서 설명해주세요
   피보나치 수열은 앞 두 수를 더해서 다음 수를 만들어가는 수열입니다.
   구현 방법으로는 단순 재귀, 메모이제이션을 활용한 재귀, 반복문 이렇게 세 가지로 설명할 수 있습니다.
   단순 재귀는 같은 계산을 여러 번 반복하기 때문에 시간 복잡도가 O(2ⁿ)으로 비효율적입니다.
   메모이제이션을 활용한 재귀는 시간 복잡도를 O(n)으로 줄일 수 있지만 추가 메모리 공간이 필요합니다.
   반복문을 이용한 방법이 가장 효율적입니다.
   0번째와 1번째 값을 미리 정해놓고, 2번째부터 n번째까지 for문을 돌려서 이전 두 값을 더해서 갱신해 나갑니다.
   구조 분해 할당을 하여 [prev, curr] = [curr, prev+curr]로 두 값을 동시에 업데이트 하면 변수를 2개만 사용하면서 공간 복잡도를 O(1)로 최소화할 수 있습니다.

3. DFS & BFS 란?
   DFS는 깊이 우선 탐색으로, 한 방향으로 갈 수 있을 만큼 최대한 깊이 내려간 후 막히면 돌아와서 다른 경로를 탐색하는 방식입니다. 스택 자료구조를 사용하거나 재귀호출로 깊이를 따라 들어갑니다. 전체 경로를 추적하거나 모든 경우의 수를 탐색할때 유용합니다.
   BFS는 너비 우선 탐색으로, 현재 노드의 이웃을 모두 방문한 다음 그 다음 단계로 넘어가는 방식입니다. 큐 자료구조를 사용합니다. 최단 경로를 찾거나 레벨별로 탐색해야 하는 문제에 유리합니다.
   **DFS는 깊게, BFS는 넓게** 탐색하는 전략입니다.
